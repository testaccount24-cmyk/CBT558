JCLSCAN  CSECT
**********************************************************************
* THIS PROGRAM READS A PROCEDURE LIBRARY AND PRODUCES A REFORMATTED  *
* OUTPUT PROCEDURE LIBRARY. BOTH FILES MUST BE PDS'S WITH RECFM=F/FB *
* AND LRECL=80. ERROR INFORMATION IS DISPLAYED TO THE PRINT1 FILE.   *
*                                                                    *
* AUTHOR R. THORNTON NOV 1974                                        *
**********************************************************************
* MODIFIED BY RNT JUN 2000                                           *
**********************************************************************
* INITIALIZE. OPEN FILES AND PREPARE AN OUTPUT DATA BLOCK.           *
**********************************************************************
         USING JCLSCAN,R3,R4
         STM   R14,R12,12(R13)         SAVE CALLER'S REGS
         LR    R3,R15                  SET UP BASE FIRST BASE REG
         LA    R4,4095(R3)             SET UP SECOND
         LA    R4,1(R4)                    BASE REGISTER
         LA    R15,MYSAVE              POINT TO MY REGISTER SAVE AREA
         ST    R15,8(R13)              SET LSA IN CALLER'S SAVE
         ST    R13,4(R15)              SET HSA IN MY SAVE AREA
         LR    R13,R15                 SET UP SAVE AREA POINTER
         B     OPENS                   BRANCH AROUND CONSTANTS
         DC    CL8'JCLSCAN'            PROGRAM NAME IDENTIFIER
         DC    CL8'&SYSDATE'           ASSEMBLY DATE
         DC    CL8'&SYSTIME'           ASSEMBLY TIME
MYSAVE   DS    18F                     MY REGISTER SAVE AREA
OPENS    OPEN  (PRINT1,OUTPUT,OUTPUT1,OUTPUT) OPEN FILES
         MVC   BLKSIZE,OUTPUT1+62      SAVE OUTPUT BLOCKSIZE
         LH    R0,BLKSIZE              PICK UP BLOCK SIZE
         GETMAIN R,LV=(0)              GET AREA TO BUILD BLOCK
         ST    R1,BLKADDR              SAVE ADDR OF BLOCK AREA
         AH    R1,BLKSIZE              COMPUTE END OF BLOCK ADDR
         BCTR  R1,R0                   BACK UP 1
         ST    R1,BLKEND               SAVE END OF BLOCK ADDR
         CALL  READDIR,OPEN            OPEN DIRECTORY FOR INPUT
         CALL  READMEM,OPEN            OPEN MEMBERS FOR INPUT
**********************************************************************
* MAINLINE PROCESSING. FOR THE INPUT1 FILE, READ NEXT DIRECTORY ENTRY*
* AND POSITION TO THE FIRST RECORD OF THE MEMBER. READ RECORDS FROM  *
* THE MEMBER AND PROCESS THEM, WRITING REFORMATTED RECORDS TO THE    *
* OUTPUT1 FILE UNTIL THE MEMBER IS EXHAUSTED. CLOSE THE OUTPUT1      *
* MEMBER AND CREATE ITS DIRECTORY ENTRY. REPEAT FOR THE NEXT INPUT1  *
* DIRECTORY ENTRY UNTIL ALL MEMBERS HAVE BEEN PROCESSED.             *
**********************************************************************
MAINLINE BAS   R9,READDIR              READ DIRECTORY AND FIND MEMBER
         MVC   CURREC,BLKADDR          RESET CURRENT RECORD ADDR
MLNEXREC BAS   R9,READMEM              READ RECORD FROM MEMBER
         CLI   RECORD,X'FF'            END OF MEMBER
         BNE   MLPROCES                NO
         BAS   R9,EOM                  YES, END OF MEMBER PROCESSING
         B     MAINLINE                AND GO READ DIRECTORY
MLPROCES BAS   R9,PROCESS              GO PROCESS THIS RECORD
         B     MLNEXREC                LOOP THRU MEMBER RECORDS
**********************************************************************
* PROCESS CONTROLS PROCESSING FOR A RECORD IN A MEMBER OF INPUT1.    *
* GENERAL JCL VALIDITY IS CHECKED. CONTINUATION RECORDS ARE SENT TO  *
* RESUME PROCESSING ROUTINES. JCL STATEMENTS ARE SENT TO APPROPRIATE *
* PROCESSING ROUTINES.                                               *
**********************************************************************
PROCESS  ST    R9,PR9                  SAVE RETURN ADDRESS
         CLC   RECORD(2),=C'//'        COL 1-2 = //
         BE    PRCKCOL3                YES
         MVC   ERTYPE(20),=C'HAS NO // IN COL 1-2'
PRERPRT  MVC   ERRMEM,DIRNAME          MEMBER NAME TO MESSAGE
         MVC   PRT,ERRMSG              ERROR MESSAGE TO PRINT
         BAS   R9,PRINT                PRINT ERROR MESSAGE
         MVC   PRT,RECORD              RECORD IN ERROR TO PRINT
         MVI   PCC,C'0'                SET DOUBLE SPACING
         BAS   R9,PRINT                GO PRINT RECORD
         MVC   0(80,R1),RECORD         RECORD TO BLOCK
         BAS   R9,WRITE                UPDATE BLOCK ADDR OR WRITE
         MVI   PROGRESS,C' '           CLEAR IN-PROGRESS INDICATOR
         MVI   CONTIN,C' '             CLEAR CONTINUATION EXPECTED INDI
         B     PRXIT                   RETURN TO MAINLINE
PRCKCOL3 CLI   RECORD+2,C' '           COL 3 IS BLANK
         BNE   PRCKCMT                 NO
         CLI   CONTIN,C','             IS CONTINUATION EXPECTED
         BNE   PRLOCBK1                NO
         CLC   RECORD+3(13),BLANX      ALL BLANK COL 4-16
         BNE   PRWHICH                 NO
         MVC   ERTYPE(27),=C'CONTINUATION BLANK COL 4-16'
         B     PRERPRT                 GO PRINT ERROR
PRWHICH  CLI   PROGRESS,C'D'           DD STATEMENT IN PROGRESS
         BE    PRDDPROG                YES
         BAS   R9,XECPROG              NO, HANDLE EXEC CONTINUATION
         B     PRXIT                   AND EXIT
PRDDPROG BAS   R9,DDPROG               NO, HANDLE DD CONTINUATION
         B     PRXIT                   AND EXIT
PRCKCMT  CLI   RECORD+2,C'*'           IS IT A COMMENT CARD
         BNE   PRLOCBK1                NO
         CLI   PROGRESS,C' '           ANY STATEMENT IN PROGRESS
         BE    XECPROG                 NO, COMMENT O.K.
         MVC   ERTYPE(29),=C'COMMENT IMBEDDED IN STATEMENT'
         B     PRERPRT                 GO PRINT ERROR
PRLOCBK1 CLI   CONTIN,C','             CONTINUATION EXPECTED
         BNE   PRSTBK1                 NO
         MVC   ERTYPE(29),=C'EXPECTED CONTINUATION MISSING'
         B     PRERPRT                 GO PRINT ERROR
PRSTBK1  LA    R2,RECORD+2             @ RECORD COLUMN 3
PRCKBLK1 CLI   0(R2),C' '              IS COLUMN BLANK
         BE    PRNONBK2                YES, GO FIND NEXT NON-BLANK
         LA    R2,1(R2)                STEP TO NEXT COLUMN
         C     R2,COL72                AT COLUMN 72 YET
         BNH   PRCKBLK1                NO
         MVC   ERTYPE(19),=C'HAS NO BLANK COLUMN'
         B     PRERPRT                 GO PRINT ERROR
PRNONBK2 LA    R2,1(R2)                STEP TO NEXT COLUMN
         C     R2,COL72                AT COLUMN 72 YET
         BNH   PRCKNBK1                NO
         MVC   ERTYPE(16),=C'CONTAINS NO DATA'
         B     PRERPRT                 GO PRINT ERROR
PRCKNBK1 CLI   0(R2),C' '              COLUMN IS BLANK
         BE    PRNONBK2                YES
         CLC   0(6,R2),=C'S INIT'      START INITIATOR COMMAND
         BE    PREXEC                  YES
         CLC   0(3,R2),=C'DD '         IS OPERATION 'DD'
         BE    PRDDSTMT                YES
         CLC   0(5,R2),=C'EXEC '       IS OPERATION 'EXEC'
         BE    PREXEC                  YES
         CLC   0(5,R2),=C'PROC '       IS OPERATION 'PROC'
         BE    PREXEC                  YES
         CLC   0(4,R2),=C'JOB '        JOB CARD
         BE    PREXEC                  YES
         MVC   ERTYPE(22),=C'UNIDENTIFIED STATEMENT'
         B     PRERPRT                 GO PRINT ERROR
PRDDSTMT BAS   R9,DDSTMT               PROCESS DD STATEMENT
         B     PRXIT                   AND EXIT
PREXEC   BAS   R9,XECPROG              PROCESS EXEC STATEMENT
PRXIT    L     R9,PR9                  GET RETURN ADDRESS
         BR    R9                      EXIT
**********************************************************************
* XECPROG HANDLES EXEC STATEMENT CONTINUATIONS.                      *
**********************************************************************
XECPROG  ST    R9,XP9                  SAVE RETURN ADDRESS
         MVI   PROGRESS,C'X'           INDIC EXEC STMT IN PROGRESS
         L     R1,CURREC               @ CURRENT LOCATION IN BLOCK
         MVC   0(80,R1),RECORD         RECORD TO BLOCK
         BAS   R9,WRITE                UPDATE BLOCK ADDR OR WRITE
         MVC   CONTIN,LASTCHAR         SET CONTINUATION INDIC
         CLI   CONTIN,C','             CONTINUATION EXPECTED
         BE    XPXIT                   YES
         MVI   PROGRESS,C' '           NO, RESET IN-PROGRESS INDIC
XPXIT    L     R9,XP9                  GET RETURN ADDRESS
         BR    R9                      RETURN TO CALLER
**********************************************************************
* DDSTMT: PROCESS DD STATEMENTS                                      *
**********************************************************************
DDSTMT   ST    R9,DD9                  SAVE RETURN ADDRESS
         MVI   PROGRESS,C'D'           INDICATE DD STATEMENT IN PROGRES
         MVC   DDWK,DDADR              RESET CURRENT DD WORK ADDR
         L     R1,DDADR                @ DDAREA
         MVC   0(80,R1),BLANX          CLEAR
         MVC   80(250,R1),0(R1)        DD
         MVC   330(250,R1),0(R1)       WORK AREA
         MVC   580(220,R1),0(R1)       TO BLANKS
         BAS   R9,DDPROG               GO SAVE STATEMENT IN WORK
DDXIT    L     R9,DD9                  GET RETURN ADDRESS
         BR    R9                      EXIT
**********************************************************************
* DDPROG HANDLES DD STATEMENT CONTINUATIONS.                         *
**********************************************************************
DDPROG   ST    R9,DP9                  SAVE RETURN ADDRESS
         LA    R11,RECORD+2            @ COL 3 OF RECORD
DPFLHE   CLI   0(R11),C' '             COLUMN IS BLANK
         BNE   DPSTRHE                 NO, FOUND LEFT-HAND END
         LA    R11,1(R11)              YES, STEP TO NEXT COLUMN
         B     DPFLHE                  LOOP TO FIND LHE
DPSTRHE  LA    R12,RECORD+70           @ RECORD COL 71
DPFRHE   CLI   0(R12),C' '             COLUMN IS BLANK
         BNE   DPSETMOV                NO, FOUND RIGHT-HAND END
         BCT   R12,DPFRHE              LOOP TO FIND RHE
DPSETMOV SR    R12,R11                 COMPUTE LENGTH CODE
         STC   R12,DPMOVE+1            SET MOVE INSTR LENGTH
         L     R1,DDWK                 @ NEXT LOCATION IN DD WORK
DPMOVE   MVC   0(1,R1),0(R11)          DD DATA TO DD WORK
         LA    R1,1(R1,R12)            TO NEXT DD WORK LOCATION
         ST    R1,DDWK                 SAVE UPDATED ADDRESS
         MVC   CONTIN,LASTCHAR         SET CONTINUATION INDIC
         CLI   CONTIN,C','             CONTINUATION EXPECTED
         BE    DPXIT                   YES
         BAS   R9,REFORMDD             NO, GO REFORMAT DD STATEMENT
         MVI   PROGRESS,C' '           CLEAR IN-PROGRESS INDIC
         MVI   CONTIN,C' '             CLEAR CONTINUATION INDIC
DPXIT    L     R9,DP9                  GET RETURN ADDRESS
         BR    R9                      EXIT
**********************************************************************
* REFORMAT DD STATEMENTS IN STANDARD FORM.                           *
**********************************************************************
REFORMDD ST    R9,RF9                  SAVE EXIT ADDRESS
         L     R11,DDADR               @ 1ST BYTE OF DD WORK AREA
         L     R12,DDWK                @ END OF DD WORK AREA
         CLC   0(8,R11),=C'SYSUDUMP'   SYSUDUMP DD CARD
         BE    RFSTDUMP                YES, REPLACE WITH STANDARD
         CLC   0(8,R11),=C'SYSABEND'   SYSABEND DD CARD
         BNE   RFCLROUT                NO
RFSTDUMP MVC   0(28,R11),STDDUMP       STANDARD DUMP DD IN WORK
         LA    R12,28(R11)             NEW RHE ADDR
         ST    R12,DDWK                STORE NEW RHE ADDR
RFCLROUT L     R10,CURREC              @ NEXT BYTE IN BLOCK
         MVC   0(80,R10),BLANX         CLEAR AREA FOR DD
         MVC   0(2,R10),=C'//'         BEGIN WITH //
         XC    DDPRMS,DDPRMS           CLEAR PARAMETER ADDRESSES
         L     R1,DDWK                 @ NEXT BYTE IN DD WORK
         MVI   0(R1),X'FF'             SET END OF DD INDIC
         LR    R8,R11                  COPY @ 1ST BYTE OF DDNAME
         SR    R7,R7                   CLEAR COUNTER REG
         CLC   0(3,R8),=C'DD '         ANY DDNAME
         BE    RFMVDDOP                NO, SKIP DDNAME EXTRACTION
RFDDNRHE CLI   0(R8),C' '              FOUND A BLANK
         BE    RFENDDN                 YES, END OF DDNAME
         LA    R8,1(R8)                STEP TO NEXT BYTE
         LA    R7,1(R7)                ADD 1 TO LENGTH COUNT
         B     RFDDNRHE                LOOP TO FIND DDNAME RHE
RFENDDN  CH    R7,=H'8'                DDNAME OVER 8 BYTES
         BNH   RFDDNLEN                NO, O.K.
         MVC   ERTYPE(15),=C'DDNAME TOO LONG'
RFERRDD  MVC   ERRMEM,DIRNAME          MEMBER NAME TO MESSAGE
         MVC   PRT,ERRMSG              ERROR MSG TO PRINT
         BAS   R9,PRINT                GO PRINT ERROR
         L     R11,DDWK                @ END OF DD WORK AREA
         MVI   0(R11),C' '             CLEAR END INDIC
         L     R11,DDADR               @ LHE DD WORK AREA
RFPDDMOV MVC PRT(80),0(R11)            DD WORK TO PRINT
         MVI   PCC,C' '                SET SINGLE SPACING
         BAS   R9,PRINT                GO PRINT
         LA    R11,80(R11)             STEP TO NEXT DD WORK LOCATION
         C     R11,DDWK                PAST END OF DD STATEMENT
         BL    RFPDDMOV                NO, CONTINUE PRINTING
         B     MAINLINE                TO NEXT MEMBER
RFDDNLEN BCTR  R7,R0                   COMPUTE DDNAME LENGTH CODE
         STC   R7,RFMVDDN+1            SET MOVE LENGTH CODE
RFMVDDN  MVC   2(1,R10),0(R11)         DDNAME TO STATEMENT
RFDDOPLH LA    R8,1(R8)                LOOK FOR DD
         CLI   0(R8),C' '              COLUMN IS BLANK
         BE    RFDDOPLH                YES, CONTINUE
         CLC   0(3,R8),=C'DD '         IS IT DD
         BE    RFMVDDOP                YES, O.K.
         MVC   ERTYPE(28),=C'UNIDENTIFIED DD FORMAT ERROR'
         B     RFERRDD                 GO PRINT ERROR
RFMVDDOP MVC   11(2,R10),=C'DD'        DD TO DD STATEMENT
         LA    R11,1(R8)               STEP TO NEXT COLUMN
RFOPLHE  LA    R11,1(R11)              STEP OVER 1 COLUMN
         CLI   0(R11),C' '             FOUND LHE 1ST OPERAND
         BE    RFOPLHE                 NO, CONTINUE LOOP
         CLI   0(R11),X'FF'            AT END OF DD WORK AREA
         BNE   RFLOCOPN                NO
         MVC   ERTYPE(18),=C'DD HAS NO OPERANDS'
         B     RFERRDD                 GO PRINT ERROR
RFLOCOPN LA    R8,1(R11)               SECOND BYTE OF OPERAND
         SR    R5,R5                   ZERO PAREN COUNTER
RFOPRHE  CLI   0(R8),C','              FOUND A COMMA
         BNE   RFCKOPFF                NO
         LTR   R5,R5                   GOT COMMA, IN PARENTHESES
         BZ    RFATOPRH                NO, FOUND RHE OPERAND
RFSTFPR  LA    R8,1(R8)                TO NEXT COLUMN
         B     RFOPRHE                 CONTINUE SEARCH FOR RHE OPERAND
RFCKOPFF CLI   0(R8),X'FF'             AT END OF DD WORK AREA
         BNE   RFCKFPNS                NO
         LTR   R5,R5                   IN PARENTHESES
         BZ    RFATOPRH                NO, AT END OF OPERAND
         MVC   ERTYPE(22),=C'UNBALANCED PARENTHESES'
         B     RFERRDD                 GO PRINT ERROR
RFCKFPNS CLI   0(R8),C'('              COLUMN CONTAINS (
         BNE   RFCKFRPN                NO
         LA    R5,1(R5)                ADD 1 TO PARENTHESES COUNT
         B     RFSTFPR                 CONTINUE SEARCH FOR RHE OPERAND
RFCKFRPN CLI   0(R8),C')'              COULMN CONTAINS )
         BE    RFDRPN                  YES
         LR    R6,R8                   COPY COLUMN ADDRESS
         BAS   R9,CKOPERD              GO CHECK IF KEYWORD
         LTR   R6,R6                   IS IT A KEYWORD
         BZ    RFSTFPR                 NO, O.K.
         LTR   R5,R5                   IN PARENTHESES
         BZ    RFUNBMIS                NO, ERROR
         CLC   0(4,R8),=C'SEP='        SEP PARAMETER
         BE    RFSTFPR                 YES, ASSUME IN UNIT
RFUNBMIS MVC   ERTYPE(8),0(R11)        8 BYTES TO ERROR MSG
         MVC   ERTYPE+9(39),=C'UNBALANCED PARENTHESES OR MISSING COMMA'
         B     RFERRDD                 GO PRINT ERROR
RFDRPN   BCTR  R5,R0                   SUBTRACT 1 FROM PAREN COUNT
         B     RFSTFPR                 CONTINUE SEARCH FOR RHE OPERAND
RFATOPRH LR    R1,R8                   COPY OPERAND RHE ADDRESS
         SR    R1,R11                  COMPUTE OPERAND LENGTH
         BCTR  R1,R0                   COMPUTE OPERAND LENGTH CODE
         CH    R1,=H'255'              EXCESSIVE LENGTH
         BNH   RFSHFTLN                NO
RFEXLEN  MVC   ERTYPE(8),0(R11)        8 BYTES OF PARAM TO MSG
         MVC   ERTYPE+9(26),=C'EXCESSIVE PARAMETER LENGTH'
         B     RFERRDD                 TO ERROR PRINTOUT
RFSHFTLN SLL   R1,24                   LEFT JUSTIFY LENGTH IN REG
         OR    R11,R1                  PUT IN HI-ORDER BYTE OF OPND @
         LR    R6,R11                  @ LHE OPERAND
         BAS   R9,CKOPERD              GO LOCATE OPERAND
         LTR   R6,R6                   VALID OPERAND
         BNZ   RFNDOPRD                YES
         MVC   ERTYPE(8),0(R11)        8 BYTES TO ERROR MSG
         MVC   ERTYPE+9(17),=C'UNDEFINED KEYWORD'
         B     RFERRDD                 GO PRINT ERROR
RFNDOPRD CLC   0(4,R6),=F'0'           OPERAND ALREADY FOUND
         BE    RFSTPADR                NO, O.K.
         MVC   ERTYPE(8),0(R11)        8 BYTES TO ERROR MSG
         MVC   ERTYPE+9(18),=C'DUPLICATED KEYWORD'
         B     RFERRDD                 GO PRINT ERROR
RFSTPADR ST    R11,0(R6)               STORE OPERAND ADDRESS
         LA    R11,1(R8)               OPERAND RHE ADDR + 1
         CLI   0(R8),X'FF'             WAS THIS LAST OPERAND
         BNE   RFLOCOPN                NO, GO LOCATE NEXT
         LA    R10,14(R10)             COL 15 @
         L     R1,CURREC               @ OUTPUT CARD AREA
         CLC   2(7,R1),=C'SORTWK0'     SORTWK0N DD CARD
         BNE   RFVOLUNT                NO
         TM    9(R1),X'F0'             LAST POSITION OF DDNAME IS NUMER
         BNO   RFVOLUNT                NO
         MVC   DDUNIT,AD3330           YES, MAKE UNIT=3330
         MVC   DDSEP,=4X'00'           CLEAR SEP PARAMETER POINTER
         TM    9(R1),1                 IS IT ODD-NUMBERED SORTWK
         BO    RFVOLUNT                YES
         IC    R1,9(R1)                NO, PICK UP LAST DIGIT
         BCTR  R1,R0                   SUBTRACT 1
         STC   R1,SEPNO                AND STORE IN SEP PARAMETER
         MVC   DDSEP,SEPAD             POINT TO SEP PARAMETER
RFVOLUNT CLC   DDDISP,=4X'00'          DISP PARAMETER RECEIVED
         BE    RFPARAM1                NO
         L     R1,DDDISP               @ DISP PARAMETER
         CLC   5(3,R1),=C'NEW'         DISP=NEW
         BE    RFCKURCV                YES
         CLC   6(3,R1),=C'NEW'         DISP=(NEW...
         BNE   RFPARAM1                NO
RFCKURCV CLC   DDUNIT,=4X'00'          UNIT PARAMETER RECEIVED
         BE    RFPARAM1                NO
         CLC   DDVOL,=4X'00'           VOL PARAMETER RECEIVED
         BNE   RFPARAM1                YES
         L     R1,DDUNIT               GET UNIT PARAMETER @
         CLC   5(4,R1),=C'3330'        UNIT=3330
         BE    RFCKSCYL                YES
         CLC   6(4,R1),=C'3330'        UNIT=(3330
         BNE   RFPARAM1                NO
RFCKSCYL CLC   DDSP,=4X'00'            SPACE PARAM RCVD
         BE    RFPARAM1                NO
         L     R1,DDSP                 @ SPACE PARAM
         CLC   6(4,R1),=C'(CYL'        SPACE IN CYLINDERS
         BNE   RFPARAM1                NO
         CLC   DDDCB,=4X'00'           DCB PARAMETER RECEIVED
         BE    RFREPLUV                NO
         L     R1,DDDCB                @ DCB PARAMETER
         LA    R1,5(R1)                STEP PAST DCB=(
         SR    R2,R2                   CLEAR REG FOR LENGTH
         IC    R2,DDDCB                GET LENGTH OF DCB PARAM
         SH    R2,=H'12'               DEDUCT FOR SCAN LENGTH
         BNP   RFREPLUV                CAN'T BE A DSORG PARAM
RFCKDSIS CLC   0(8,R1),=C'DSORG=IS'    HAS IT DSORG=IS
         BE    RFPARAM1                YES, DON'T CHANGE UNIT, VOL
         LA    R1,1(R1)                STEP TO NEXT POSITION
         BCT   R2,RFCKDSIS             LOOP TO FIND DSORG=IS
RFREPLUV MVC   DDUNIT,NUADR            SET POINTER TO REPLACEMENT UNIT
         MVC   DDVOL,NVADR             SET POINTER TO REPLACEMENT VOL
RFPARAM1 CLC   DDDCB,=4X'00'           DCB PARAM RECVD
         BE    RFORMAT                 NO
         L     R11,DDDCB               @ DCB PARAM
         LA    R11,4(R11)              @ 1ST BYTE OF LIST
         SR    R12,R12                 CLEAR WORK REG
         IC    R12,DDDCB               GET LENGTH CODE
         SH    R12,=H'7'               REDUCE LENGTH CODE
         BNP   RFORMAT                 WENT NEGATIVE
RFHNTDEN CLC   0(5,R11),=C'DEN=2'      DEN=2 SPECIFIED
         BNE   RFDENSKP                NOT HERE
         MVC   DDUNIT,TP7UNIT          SET UNIT=TAPE7
         B     RFORMAT                 AND GO FORMAT
RFDENSKP LA    R11,1(R11)              STEP TO NEXT POS
         BCT   R12,RFHNTDEN            LOOP THRU DCB PARAM
RFORMAT  LA    R12,DDPRMS              @ PARAMETER ADDRESS LIST
         LA    R11,69                  END COLUMN NBR
         A     R11,CURREC              @ END OUTPUT COLUMN
RFCKRCVD CLC   0(4,R12),=4X'00'        PARAMETER RECEIVED
         BNE   RFCHKFIT                YES, GO CHECK FIT
RFNXTPAR LA    R12,4(R12)              TO NEXT PARAMETER ADDR
         CLC   0(2,R12),=X'FEFE'       END OF ADDR TBL
         BNE   RFCKRCVD                NO
         B     RFENDOFP                YES ALL THRU
RFCHKFIT SR    R1,R1                   CLEAR WORK REG
         IC    R1,0(R12)               GET PARAMETER LENGTH CODE
         CH    R1,=H'54'               PARAMETER TOO LONG
         BNH   RFCALCND                NO
         L     R1,CURREC               @ LHE CURRENT RECD
         LA    R1,14(R1)               @ COL 15
         CR    R1,R10                  CURRENTLY AT COL 15
         BNE   RFNOMORE                NO
         L     R1,0(R12)               @ LHE PARAMETER
         LR    R2,R1                   COPY PARAMETER ADDR
         LA    R1,54(R1)               @ PARAMETER+54
RFBAKOMA CLI   0(R1),C','              FOUND A COMMA
         BE    RFCOM                   YES
         CR    R1,R2                   NO, AT LEFT END OF PARAM
         BNE   RFSTPBAK                NO, CONTINUE SEARCH
         L     R11,0(R12)              @ LHE PARAMETER
         B     RFEXLEN                 GO PRINT ERROR
RFSTPBAK BCT   R1,RFBAKOMA             LOOP TO FIND COMMA
RFCOM    SH    R12,=H'4'               BACK UP TO RE-USE PREV ENTRY
         MVC   0(4,R12),4(R12)         COPY ORIGINAL ENTRY
         LA    R15,1(R1)               @ LHE NEXT PORTION
         STCM  R15,7,5(R12)            STORE IN ORIGINAL ENTRY
         SR    R1,R2                   COMPUTE 1ST PORTION LENGTH CODE
         BCTR  R1,R0                   DONT INCLUDE COMMA
         STC   R1,0(R12)               STORE 1ST PORTION LENGTH CODE
         SR    R2,R2                   CLEAR WORK REG
         IC    R2,4(R12)               PICK UP ORIGINAL LENGTH CODE
         SR    R2,R1                   COMPUTE 2ND PORTION LENGTH
         BCTR  R2,R0                   MINUS 1 = LENGTH
         BCTR  R2,R0                   MINUS 1 = LENGTH CODE
         STC   R2,4(R12)               SET 2ND PORTION LENGTH CODE
RFCALCND LA    R1,0(R1,R10)            COMPUTE MAX LENGTH REQRD IF USED
         CR    R1,R11                  PAST END OF CARD
         BNH   RFMVPAR                 NO
RFNOMORE BAS   R9,WRITE                UPDATE BLOCK @ OR WRITE
         L     R10,CURREC              GET CURRENT RECORD LOC
         LA    R11,69(R10)             @ LAST COLUMN
         MVC   0(80,R10),BLANX
         MVC   0(2,R10),=C'//'         COL 1-2 = //
         LA    R10,14(R10)             STEP TO COL 15
         B     RFCHKFIT                GO CHECK FIT
RFMVPAR  MVC   RFMOVPAR+1(1),0(R12)    LENGTH CODE TO MOVE INSTR
         L     R1,0(R12)               GET PARAMETER ADDRESS
RFMOVPAR MVC   0(1,R10),0(R1)          PARAMETER TO OUTPUT RECORD
         SR    R1,R1                   CLEAR WORK REG
         IC    R1,0(R12)               GET PARAMETER LENGTH CODE
         LA    R10,0(R1,R10)           COMPUTE NEXT OUTPUT RECORD BYTE
         LA    R1,4(R12)               @ NEXT PARAM LIST ADDR
RFCKRCV2 CLC   0(4,R1),=4X'00'         PARAMETER RECEIVED
         BNE   RFNOTHR1                YES
         LA    R1,4(R1)                TO NEXT TBL ADDR
         B     RFCKRCV2                LOOP
RFNOTHR1 CLC   0(2,R1),=X'FEFE'        END OF TABLE
         BE    RFENDOFP                YES
         MVI   1(R10),C','             ANOTHER PARAMETER, SET COMMA
         LA    R10,2(R10)              STEP PAST COMMA
         B     RFNXTPAR                CONTINUE
RFENDOFP BAS   R9,WRITE                GO UPDATE BLOCK ADDR OR WRITE
RFXIT    L     R9,RF9                  GET RETURN ADDR
         BR    R9                      EXIT
**********************************************************************
* CHECK FOR A VALID OPERAND FOR A DD STATEMENT. IF IT IS A VALID     *
* OPERAND, RETURN THE ADDRESS OF THE TABLE IN R6. IF NOT VALID, R6=0.*
**********************************************************************
CKOPERD  SR    R2,R2                   CLEAR REG FOR TRT
         TRT   0(1,R6),KEYSCAN         IS 1ST CHARACTER THAT OF A KEYWO
         BNZ   GETKEY                  YES, GO CHECK FURTHER
NOKEY    SR    R6,R6                   NOT A KEYWORD, SO INDICATE
         BR    R9                      EXIT
GETKEY   SLL   R2,2                    MULTIPLY INDEX BY 4
BRTBL    B     BRTBL(R2)               ENTER BRANCH TABLE
         B     KEYD                    1ST CHARACTER IS D
         B     KEYL                    1ST CHARACTER IS L
         B     KEYS                    1ST CHARACTER IS S
         B     KEYU                    1ST CHARACTER IS U
         B     KEYV                    1ST CHARACTER IS V
         B     KEYQ                    1ST CHARACTER IS Q
         B     KEYM                    1ST CHARACTER IS M
         B     KEYF                    1ST CHARACTER IS F
KEYD     CLC   0(4,R6),=C'DSN='        IS IT DSN
         BNE   KEYD1                   NO
SETDSN   LA    R6,DDDSN                YES, GET TBL ADDR
         BR    R9                      EXIT
KEYD1    CLC   0(7,R6),=C'DSNAME='     IS IT DSNAME
         BE    SETDSN                  YES
         CLC   0(5,R6),=C'DISP='       IS IT DISP
         BNE   KEYD2                   NO
         LA    R6,DDDISP               YES, GET TBL ADDR
         BR    R9                      EXIT
KEYD2    CLC   0(4,R6),=C'DCB='        IS IT DCB
         BNE   KEYD3                   NO
         LA    R6,DDDCB                YES, GET TBL ADDR
         BR    R9                      EXIT
KEYD3    CLC   0(5,R6),=C'DUMMY'       IS IT DUMMY
         BE    SETDSN                  YES
KEYD4    CLC   0(7,R6),=C'DDNAME='     IS IT DDNAME
         BNE   NOKEY                   NO, NOT A KEYWORD
         LA    R6,DDDDN                YES, GET TBL ADDR
         BR    R9                      EXIT
KEYL     CLC   0(6,R6),=C'LABEL='      IS IT LABEL
         BNE   NOKEY                   NO, NOT A KEYWORD
         LA    R6,DDLBL                YES, GET TBL ADDR
         BR    R9                      EXIT
KEYS     CLC   0(7,R6),=C'SYSOUT='     IS IT SYSOUT
         BE    SETDSN                  YES
         CLC   0(6,R6),=C'SPACE='      IS IT SPACE
         BNE   KEYS1                   NO
         LA    R6,DDSP                 YES, GET TBL ADDR
         BR    R9                      EXIT
KEYS1    CLC   0(6,R6),=C'SPLIT='      IS IT SPLIT
         BNE   KEYS2                   NO
         LA    R6,DDSPL                YES, GET TBL ADDR
         BR    R9                      EXIT
KEYS2    CLC   0(9,R6),=C'SUBALLOC='   IS IT SUBALLOC
         BNE   KEYS3                   NO, NOT A KEY
         LA    R6,DDSUB                YES, GET TBL ADDR
         BR    R9                      EXIT
KEYS3    CLC   0(4,R6),=C'SEP='        IS IT SEP
         BNE   NOKEY                   NO
         LA    R6,DDSEP                YES, GET TBL ADDR
         BR    R9                      EXIT
KEYU     CLC   0(5,R6),=C'UNIT='       IS IT UNIT
         BNE   KEYU1                   NO
         LA    R6,DDUNIT               YES, GET TBL ADDR
         BR    R9                      EXIT
KEYU1    CLC   0(4,R6),=C'UCS='        IS IT UCS
         BNE   NOKEY                   NO, NOT A KEYWORD
         LA    R6,DDUCS                YES, GET TBL ADDR
         BR    R9                      EXIT
KEYV     CLC   0(4,R6),=C'VOL='        IS IT VOL
         BE    SETVOL                  YES
         CLC   0(7,R6),=C'VOLUME='     IS IT VOLUME
         BNE   NOKEY                   NO, NOT A KEYWORD
SETVOL   LA    R6,DDVOL                YES, GET TBL ADDR
         BR    R9                      EXIT
KEYM     CLC   0(8,R6),=C'MONITOR='    IS IT MONITOR?
         BNE   NOKEY                   NO, NOT A KEYWORD
         LA    R6,DDMON                YES, GET TBL ADDR
         BR    R9                      EXIT
KEYF     CLC   0(9,R6),=C'FOOTPRNT='   IS IT FOOTPRINT?
         BNE   NOKEY                   NO, NOT A KEYWORD
SETFTPT  LA    R6,DDFTPT               YES, GET TBL ADDR
         BR    R9                      EXIT
KEYQ     CLC   0(6,R6),=C'QNAME='      IS IT QNAME
         BE    SETDSN                  YES
         B     NOKEY                   NO, NOT A KEYWORD
**********************************************************************
* PRINT A LINE TO THE ERROR LISTING                                  *
**********************************************************************
PRINT    ST    R9,PT9                  SAVE RETURN ADDRESS
         PUT   PRINT1,PCC              WRITE PRINT RECORD
         MVC   PRT,BLANX               CLEAR PRINT LINE
         MVC   ERTYPE,BLANX            CLEAR ERROR TYPE
         MVI   PCC,C'0'                SET DOUBLE SPACING
PTXIT    L     R9,PT9                  GET RETURN ADDRESS
         BR    R9                      EXIT
**********************************************************************
* READ NEXT DIRECTORY ENTRY FROM THE INPUT1 FILE                     *
**********************************************************************
READDIR  ST    R9,RD9                  SAVE RETURN ADDRESS
         CALL  READDIR,(READ,DIRCTY)   READ DIRECTORY RECORD
         CLI   DIRCTY,X'FF'            END OF DIRECTORY
         BE    EOJ                     YES, ALL DONE
         MVC   FINDTTR,DIRTTR          TTR TO FIND PARAMETER
         CALL  READMEM,FIND            GO FIND MEMBER
RDXIT    L     R9,RD9                  GET RETURN ADDRESS
         BR    R9                      EXIT
**********************************************************************
* READ NEXT RECORD FROM CURRENT MEMBER IN THE INPUT1 FILE            *
**********************************************************************
READMEM  ST    R9,RM9                  SAVE RETURN ADDRESS
         CALL  READMEM,(READ,RECORD)   READ NEXT RECORD
         LA    R1,RECORD               @ LHE RECORD
         LA    R2,POS72                @ COL 72
         MVC   LASTCHAR,POS72          COL 72 TO CONTIN BYTE
         CLI   LASTCHAR,C' '           IS COL 72 BLANK
         BE    CKENDBK                 YES
         MVI   LASTCHAR,C','           COL 72 NON-BLANK, FORCE COMMA
         BR    R9                      EXIT
CKENDBK  CLI   0(R2),C' '              COLUMN IS BLANK
         BNE   SETLAST                 NO
         BCTR  R2,R0                   BACK UP 1 COLUMN
         CR    R1,R2                   PAST COLUMN 1
         BL    CKENDBK                 NO, CONTINUE
SETLAST  MVC   LASTCHAR,0(R2)          LAST NON-BLANK IN CARD
RMXIT    L     R9,RM9                  GET RETURN ADDRESS
         BR    R9                      EXIT
**********************************************************************
* ADD A RECORD TO THE OUTPUT BLOCK IN PROGRESS. WHEN THE BLOCK IS    *
* FULL, WRITE IT USING A WRITE MACRO AND PREPARE A NEW BLOCK.        *
**********************************************************************
WRITE    ST    R9,WR9                  SAVE RETURN ADDRESS
         L     R1,CURREC               CURRENT BLOCK LOCATION @
         AP    SEQN,=P'10'             INCREMENT OUTPUT SEQUENCE NBR
         UNPK  72(8,R1),SEQN           SEQUENCE NBR TO OUTPUT RECD
         OI    79(R1),C'0'             CLEAR SIGN
         LA    R1,80(R1)               STEP TO NEXT BLOCK LOCATION
         ST    R1,CURREC               UPDATE CURRENT LOCATION @
         C     R1,BLKEND               AT END OF BLOCK
         BCR   4,R9                    LOW, NO
         ST    R12,SAV12               SAVE REG 12
         L     R12,BLKADDR             YES, GET BLOCK ADDR
         ST    R12,CURREC              RESET CURRENT LOCATION ADDR
         WRITE OUTDECB,SF,OUTPUT1,(12),'S' WRITE THE BLOCK
         CHECK OUTDECB                 WAIT COMPLETION
         L     R12,SAV12               RESTORE REG 12
WRXIT    L     R9,WR9                  GET RETURN ADDRESS
         BR    R9                      EXIT
**********************************************************************
* END OF MEMBER ROUTINE. WRITE LAST BLOCK OF DATA AND CREATE THE     *
* DIRECTORY ENTRY USING THE STOW MACRO.
**********************************************************************
EOM      ST    R9,EO9                  SAVE RETURN ADDRESS
         CLC   BLKADDR+1(3),CURREC+1   ANY RECORDS IN BLOCK
         BE    STOW                    NO
         L     R1,CURREC               YES, GET CURRENT LOCATION @
         S     R1,BLKADDR              COMPUTE REAL BLOCK LENGTH
         STH   R1,OUTPUT1+62           MODIFY DCBLKSI FOR SHORTER LENGT
         L     R12,BLKADDR             GET BLOCK ADDRESS
         ST    R12,CURREC              RESET CURRENT RECORD ADDR
         WRITE SHRTDECB,SF,OUTPUT1,(12),'S' WRITE SHORT BLOCK
         CHECK SHRTDECB                WAIT COMPLETION
         MVC   OUTPUT1+62(2),BLKSIZE   RESET DCBLKSI
STOW     MVC   DIRTTR,X'000000'        ZERO TTR, BPAM SUPPLIES
         STOW  OUTPUT1,DIRCTY,A        ADD DIRECTORY ENTRY
         ZAP   SEQN,=P'0'              CLEAR SEQUENCE NBR
EOXIT    L     R9,EO9                  GET RETURN ADDRESS
         BR    R9                      EXIT
**********************************************************************
* END OF JOB. CLOSE FILES AND TERMINATE PROCESSING                   *
**********************************************************************
EOJ      CALL  READDIR,CLOSE           CLOSE DIRECTORY FILE
         CALL  READMEM,CLOSE           CLOSE MEMBER FILE
         CLOSE (OUTPUT1,,PRINT1)       CLOSE PRINT AND OUTPUT FILES
         L     R13,4(R13)              GET CALLER'S SAVE ADDR
         LM    R14,R12,12(R13)         RESTORE HIS REGS
         SR    R15,R15                 CLEAR RETURN CODE
         BR    R14                     RETURN TO CALLER
**********************************************************************
* CONSTANTS, VARIABLES, RECORDS, AND WORK AREAS                      *
**********************************************************************
EO9      DC    A(0)                    RETURN ADDRESS FOR EOM
DD9      DC    A(0)                    RETURN ADDRESS FOR DDSTMT
PT9      DC    A(0)                    RETURN ADDRESS FOR PRINT
RD9      DC    A(0)                    RETURN ADDRESS FOR READDIR
RM9      DC    A(0)                    RETURN ADDRESS FOR READMEM
WR9      DC    A(0)                    RETURN ADDRESS FOR WRITE
PR9      DC    A(0)                    RETURN ADDRESS FOR PROCESS
XP9      DC    A(0)                    XECPROG RETURN ADDRESS
DP9      DC    A(0)                    DDPROG RETURN ADDRESS
RF9      DC    A(0)                    REFORMDD RETURN ADDRESS
OPEN     DC    CL9'OINPUT1'            OPEN PARAMETER
READ     DC    C'R'                    READ PARAMETER
CLOSE    DC    C'C'                    CLOSE PARAMETER
DIRCTY   DS    0CL11                   READ DIRECTORY PARAMETER
DIRNAME  DS    CL8                     DIRECTORY NAME
DIRTTR   DS    XL3                     DIRECTORY TTR OF MEMBER
         DC    X'00'                   Z FOR TTRZ IN OUTPUT DIRECTORY E
BLKSIZE  DS    H                       OUTPUT BLOCK SIZE
BLKADDR  DS    F                       @ OUTPUT BLOCK AREA
BLKEND   DS    F                       @ END OF OUTPUT BLOCK
CURREC   DS    F                       @ CURRENT LOCATION IN OUTPUT BLO
SAV12    DS    F                       SAVE AREA FOR REG 12
SEQN     DC    PL5'0'                  OUTPUT RECORD SEQUENCE NBR
LASTCHAR DS    CL1                     CONTINUATION INDIC, THIS RECD
STDDUMP  DC    CL28'SYSUDUMP DD SYSOUT=(A,,DUMP)'
SORTEXEC DS    0CL49                   EXECUTE CARD FOR SORT
         DC    CL2'//'
SORTNAME DS    CL8                     SORT STEP NAME
         DC    CL39' EXEC PGM=SORT33,PARM=''CORE=MAX,MSG=AP'''
         DS    0F
SEPAD    DC    FL1'11'                 SEP PARAMETER LENGTH
         DC    AL3(SEPP)               @ SEP PARAMETER
SEPP     DC    CL11'SEP=SORTWK0'       1ST 7 POSITIONS OF SEP PARAMETER
SEPNO    DS    CL1                     LAST POSITION OF SEP PARAMETER
         DS    0F
AD3330   DC    FL1'8'                  LENGTH CODE OF UNIT PARAMETER
         DC    AL3(UN3330)             @ UNIT=3330 PARAMETER
UN3330   DC    CL9'UNIT=3330'
NUADR    DS    0F                      REPLACEMENT UNIT ADDR
         DC    FL1'12'                 LENGTH
         DC    AL3(NUNIT)              ADDR OF REPLACEMENT UNIT
         DS    0F
TP7UNIT  DC    FL1'9'                  LENGTH CODE OF TAPE7 UNIT
         DC    AL3(TP7UNT)             @ TAPE7 UNIT PARAM
NVADR    DS    0F                      REPLACEMENT VOL ADDR
         DC    FL1'9'                  LENGTH OF REPLACEMENT VOL
         DC    AL3(NVOL)               ADDR OF REPLACEMENT VOL
NUNIT    DC    C'UNIT=(3330,3)'
NVOL     DC    C'VOL=(,,,3)'
TP7UNT   DC    CL10'UNIT=TAPE7'        UNIT PARAM FOR DCB=DEN=2
FIND     DS    0CL5                    FIND PARAMETER
         DC    C'FT'                   FIND BY TTR
FINDTTR  DS    XL3                     TTR TO FIND
RECORD   DS    0CL80                   INPUT RECORD AREA
         DS    CL71                    RECORD DATA AREA
POS72    DS    CL1                     COLUMN 72
         DS    CL8                     LAST 8 COLUMNS
COL72    DC    A(POS72)                @ RECORD COLUMN 72
         DS    F                       DUMMY ENTRY FOR EXCESS LENGTH
DDPRMS   DS    0CL48                   ADDRESSES OF DD PARAMETERS
*                                      1ST BYTE IS LENGTH CODE
DDDSN    DS    F                       DSN PARAMETER
DDDISP   DS    F                       DISP PARAMETER
DDUNIT   DS    F                       UNIT PARAMETER
DDVOL    DS    F                       VOL PARAMETER
DDLBL    DS    F                       LABEL PARAMETER
DDSP     DS    F                       SPACE PARAMETER
DDDCB    DS    F                       DCB PARAMETER
DDSEP    DS    F                       SEP PARAMETER
DDDDN    DS    F                       DDNAME PARAMETER
DDUCS    DS    F                       UCS PARAMETER
DDSPL    DS    F                       SPLIT PARAMETER
DDSUB    DS    F                       SUBALLOC PARAMETER
DDMON    DS    F                       MONITOR PARAMETER
DDFTPT   DS    F                       FOOTPRNT PARAMETER
         DC    X'FEFE'                 END OF TABLE
ERRMSG   DC    CL18'FOLLOWING CARD IN'
ERRMEM   DS    CL8                     MEMBER NAME
         DC    CL1' '
ERTYPE   DC    CL53' '                 TYPE ERROR FOUND
BLANX    DC    CL80' '                 CONSTANT BLANKS
PCC      DC    C' '                    PRINT CARRIAGE CONTROL
PRT      DC    CL80' '                 PRINT AREA
PROGRESS DC    C' '                    IN-PROGRESS INDICATOR
*                                       ' ' = NOTHIN IN PROGRESS
*                                       'D' = DD STATEMENT IN PROGRESS
*                                       'X' = EXEC/PROC IN PROGRESS
CONTIN   DC    C' '                    CONTINUATION INDICATOR
*                                       ',' = CONTINUATION EXPECTED
DDWK     DC    A(DDAREA)               @ CURRENT LOCATION IN DD WORK
DDADR    DC    A(DDAREA)               @ 1ST BYTE OF DD WORK AREA
KEYSCAN  DC    XL256'0'                TRT TABLE TO SCAN FOR KEYWORDS
         ORG   KEYSCAN+C'D'
         DC    X'01'
         ORG   KEYSCAN+C'L'
         DC    X'02'
         ORG   KEYSCAN+C'S'
         DC    X'03'
         ORG   KEYSCAN+C'U'
         DC    X'04'
         ORG   KEYSCAN+C'V'
         DC    X'05'
         ORG   KEYSCAN+C'Q'
         DC    X'06'
         ORG   KEYSCAN+C'M'
         DC    X'07'
         ORG   KEYSCAN+C'F'
         DC    X'08'
         ORG
**********************************************************************
* FILE DEFINITIONS                                                   *
**********************************************************************
OUTPUT1  DCB   DSORG=PO,MACRF=W,DDNAME=OUTPUT1,                        X
               RECFM=FB,LRECL=80
PRINT1   DCB   DSORG=PS,MACRF=PM,DDNAME=PRINT1,                        X
               RECFM=FA,LRECL=81,BLKSIZE=81
**********************************************************************
* LARGE STORAGE AREAS                                                *
**********************************************************************
         LTORG
DDAREA   DS    10CL80                  DD STATEMENT WORK AREA
*********************************************************************
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
