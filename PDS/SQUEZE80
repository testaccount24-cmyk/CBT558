         TITLE '***** SQUEZE80: COPY LONG RECS TO 80-BYTE FILE *****'
         PRINT NOGEN
SQUEZE80 SVLNK R3
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*   THIS PROGRAM COPIES AN INPUT FILE TO AN OUTPUT FILE CONTAINING    *
* FIXED LENGTH 80-BYTE LOGICAL RECORDS. INPUT RECORDS ARE MODIFIED TO *
* FIT THE 80-BYTE OUTPUT RECORD BY USE OF A PSEUDO VBS CONCEPT IN     *
* WHICH INPUT RECORDS ARE BROKEN INTO PARTS OF LESS THAN 78 BYTES     *
* EACH, WHICH ARE PRECEDED BY A TWO BYTE PART DESCRIPTOR. THE FIRST   *
* BYTE OF THE PART DESCRIPTOR IS THE LENGTH OF THE PART. THE SECOND   *
* DESCRIPTOR BYTE SPECIFIES WHETHER THIS PART IS THE FIRST, LAST, OR  *
* AN INTERMEDIATE PART OF A LOGICAL RECORD. THE INPUT FILE MUST HAVE  *
* DSORG=PS, DSORG=DA, OR DSORG=PO SO THAT IT CAN BE READ SEQUENTIALLY *
* USING QSAM. INPUT RECORDS MAY BE FIXED, VARIABLE, UNDEFINED, OR     *
* VARIABLE SPANNED.                                                   *
*                                                                     *
* THE FIRST RECORD IN THE OUTPUT FILE CONTAINS INFORMATION FROM THE   *
* DCB FOR THE INPUT FILE, INCLUDING THE DSORG, RECFM, AND LRECL. THIS *
* IS USED BY THE UNSQUZ80 PROGRAM IN RECONSTRUCTING THE FILE. WHEN    *
* FEWER THAN 3 BYTES REMAIN IN AN 80-BYTE OUTPUT RECORD, NO ADDITIONAL*
* DATA WILL FIT. IN THIS CASE, AND FOR THE LAST 80-BYTE RECORD IN THE *
* FILE, A PART DESCRIPTOR OF ALL HEX ZEROS INDICATES THERE IS NO MORE *
* DATA IN THIS 80-BYTE RECORD.                                        *
*                                                                     *
*    THIS PROGRAM IS INTENDED PRIMARILY FOR THE CREATION OF CLASSROOM *
* HANDOUTS FOR A DUMP CLASS, WHERE COMPILE LISTINGS, ASSEMBLY LISTINGS*
* JCL, AND DUMP LISTINGS ARE WRITTEN AS MEMBERS OF A STANDARD PDS WITH*
* RECFM=FB,LRECL=80. THE UNSQUZ80 PROGRAM MUST BE USED TO PRINT THESE *
* MEMBERS.                                                            *
* AUTHOR R THORNTON    MAY 1986                                       *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
         OPEN  (OUTPUT1,OUTPUT,INPUT1)
         TM    INRECFM,INUNDEF   TEST RECFM
         BZ    BADFORM           RECFM=? NOT ACCEPTABLE
         TM    INRECFM,INFIX     TEST RECFM
         BO    TESTORGN          RECFM=F.. IS O.K.
         TM    INRECFM,INSPAN    RECFM=V, TEST RECFM
         BZ    TESTORGN          NOT SPANNED, CONTINUE
         CLOSE INPUT1            CLOSE NORMAL DEFINITION
         GETMAIN R,LV=32768      GET AREA FOR RECORD ASSEMBLY
         ST    R1,VBSADR         SAVE THE ADDRESS
         MVC   INPUT1(VBSEND-VBSDCB),VBSDCB REPLACE WITH MACRF=GD
         OPEN  INPUT1            OPEN VBS DCB WITH MACRF=GD
         B     TESTORGN
BADFORM  WTO   'ILLEGAL RECFM, USE F, V, OR U ONLY FOR INPUT1',        X
               ROUTCDE=11
         ABEND 111,DUMP
TESTORGN TM    INDSORG,INPS      TEST LRECL
         BO    FRSTRECD          DSORG=PS IS O.K.
         TM    INDSORG,INDA      TEST LRECL
         BO    FRSTRECD          DSORG=DA IS O.K.
         TM    INDSORG,INPO      TEST LRECL
         BO    FRSTRECD          DSORG=PO IS O.K.
         WTO   'ILLEGAL DSORG, USE PS, DA, OR PO ONLY FOR INPUT1',     X
               ROUTCDE=11
         ABEND 222,DUMP
FRSTRECD MVC   OUTREC(1),INDSORG DSORG TO OUTPUT
         MVC   OUTREC+1(1),INRECFM RECFM TO OUTPUT
         MVC   OUTREC+2(2),INLRECL LRECL TO OUTPUT
         PUT   OUTPUT1,OUTREC    WRITE FIRST RECORD
         XC    OUTREC,OUTREC     CLEAR THE RECORD AREA
         LA    R6,OUTREC         POINT TO OUTPUT RECORD
         USING OUTDESC,R6
*
*
*
MAINLINE BAL   R9,GETINP         READ NEXT INPUT RECORD
         OI    PARTYPE,FRSTPART  SET FIRST PART FLAG
CKFIT    CLC   INLEFT,OTLEFT     INPUT WILL FIT IN OUTPUT?
         BH    TOOLONG           NO
         OI    PARTYPE,LASTPART  INDICATE LAST PART OF RECORD
         LH    R1,INLEFT         GET PART LENGTH
         BAL   R9,WRITPART       MOVE PART TO OUTPUT AREA
         B     MAINLINE          GO TO NEXT INPUT RECORD
TOOLONG  LH    R1,OTLEFT         GET PART LENGTH
         BAL   R9,WRITPART       MOVE PART TO OUTPUT AREA
         B     CKFIT             CONTINUE
*
*        MOVE PART OF INPUT RECORD TO OUTPUT AREA, WRITE IF FULL
*
WRITPART STC   R1,PARTLEN        PUT PART LENGTH IN OUTPUT PD
         BCTR  R1,0              COMPUTE MVC LENGTH CODE
         EX    R1,PARTMOVE       MOVE DATA TO OUTPUT RECORD
         LA    R1,1(R1)          REAL LENGTH AGAIN
         LH    R2,INLEFT         DEDUCT BYTES
         SR    R2,R1                MOVED FROM
         STH   R2,INLEFT              INPUT TO OUTPUT
         LH    R2,OTLEFT         DEDUCT BYTES
         SR    R2,R1                MOVED FROM
         SH    R2,H2                  INPUT TO OUTPUT PLUS
         STH   R2,OTLEFT                NEXT DESCRIPTOR LENGTH
         AR    R7,R1             POINT TO NEXT INPUT BYTE
         LA    R6,2(R1,R6)       POINT TO NEXT OUTPUT BYTE
         CH    R2,H3             AT LEAST 3 BYTES LEFT?
         BNL   WRITXIT           YES
         PUT   OUTPUT1,OUTREC    WRITE THE RECORD
         XC    OUTREC,OUTREC     CLEAR THE RECORD
         LA    R6,OUTREC         POINT TO OUTPUT RECORD
         MVC   OTLEFT,H78        SET OUTPUT REC BYTES LEFT
WRITXIT  BR    R9                EXIT
PARTMOVE MVC   PARTDATA(1),0(R7) EXECUTED MOVE
*
*        GET NEXT INPUT RECORD
*
GETINP   TM    INRECFM,INVRBL+INSPAN VARIABLE SPANNED RECORDS?
         BO    INVSPND           YES
         GET   INPUT1            READ NEXT INPUT RECORD
         LR    R7,R1             POINT TO INPUT RECORD
         TM    INRECFM,INVRBL    VARIABLE RECORDS?
         BO    INVBL             YES
         MVC   INLEFT,INLRECL    SET NBR BYTES LEFT
         BR    R9                EXIT
INVBL    LH    R1,0(R7)          GET DATA+RDW LENGTH FROM RDW
         SH    R1,H4             COMPUTE DATA LENGTH
         STH   R1,INLEFT         SET INPUT BYTES LEFT
         LA    R7,4(R7)          POINT PAST THE RDW TO FIRST DATA BYTE
         BR    R9                EXIT
INVSPND  L     R7,VBSADR         POINT TO RECORD ASSEMBLY AREA
         GET   INPUT1,0(R7)      READ NEXT INPUT RECORD
         MVC   INLEFT,INLRECL    SET NBR BYTES LEFT
         BR    R9                RETURN
*
*        END OF JOB
*
EOJ      CLC   OTLEFT,H78        ANYTHING IN LAST OUTPUT RECORD?
         BE    EOJ1              NO
         PUT   OUTPUT1,OUTREC    YES, WRITE IT
EOJ1     CLOSE (OUTPUT1,,INPUT1)   CLOSE FILES
         L     R13,4(R13)        POINT TO CALLER'S SAVE
         LM    R14,R12,12(R13)   RESTORE CALLER'S REGS
         SR    R15,R15           CLEAR RETURN CODE
         BR    R14               RETURN TO CALLER
*
*
*
VBSADR   DC    A(0)               GOTTEN STORAGE FOR VBS MACRF=GD
INLEFT   DC    H'0'               INPUT RECORD BYTES LEFT
OTLEFT   DC    H'78'              OUTPUT RECORD BYTES LEFT
H2       DC    H'2'               CONSTANT 2
H3       DC    H'3'               CONSTANT 3
H4       DC    H'4'               CONSTANT 4
H78      DC    H'78'              CONSTANT 78
H156     DC    H'156'             CONSTANT 156
OUTREC   DC    XL80'00'           OUTPUT RECORD
*
*
*
OUTPUT1  DCB   DSORG=PS,MACRF=PM,DDNAME=OUTPUT1,                       X
               RECFM=FB,LRECL=80
INPUT1   DCB   DSORG=PS,MACRF=GL,DDNAME=INPUT1,EODAD=EOJ
INDSORG  EQU   INPUT1+26          DSORG
INPS     EQU   X'40'              PHYSICAL SEQUENTIAL
INDA     EQU   X'20'              DIRECT ACCESS
INPO     EQU   X'02'              PARTITIONED
INRECFM  EQU   INPUT1+36          RECFM
INUNDEF  EQU   X'C0'              UNDEFINED
INFIX    EQU   X'80'              FIXED
INVRBL   EQU   X'40'              VARIABLE
INSPAN   EQU   X'08'              SPANNED (IF VARIABLE)
INLRECL  EQU   INPUT1+82
VBSDCB   DCB   DSORG=PS,MACRF=GD,DDNAME=INPUT1,EODAD=EOJ
VBSEND   EQU   *
         LTORG
*
*        OUTPUT PART DESCRIPTOR DSECT
*
OUTDESC  DSECT ,                 OUTPUT PART DESCRIPTION
PARTDESC DS    0XL2              PART DESCRIPTOR
PARTLEN  DS    XL1               PART DATA LENGTH (NOT INCL DESC)
PARTYPE  DS    XL1               PART TYPE FLAGS
FRSTPART EQU   X'80'             FIRST PART OF A RECORD
LASTPART EQU   X'01'             LAST PART OF A RECORD
PARTDATA DS    0X                PART DATA, 1-78 BYTES
SQUEZE80 CSECT
         END
