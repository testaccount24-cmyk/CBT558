         PRINT ON
         PRINT GEN
         PRINT NODATA
         PRINT NOMCALL
         PRINT NOMSOURCE
         PRINT UHEAD
   TITLE  '*** LMODREAD: READ LOAD MODULE USING IEWB... MACROS ***'
LMODREAD CSECT
LMODREAD AMODE 31
LMODREAD RMODE 24
***********************************************************************
*  READS A LOAD MODULE USING THE IEWBUFF AND IEWBIND MACROS AND PRINTS*
*  THE RESULTS.                                                       *
*                                                                     *
*  FILES USED:                                                        *
*  READER1: CONTROL RECORDS. EACH RECORD IS EITHER A COMMENT (* IN    *
*           COLUMN 1), OR CONTAINS A MEMBER NAME IN COL 1-8 AND CSECT *
*           NAME IN COL 10-17.                                        *
*  PRINT1:  ERROR AND EXCEPTION LISTING                               *
*  OUTPUT1: LOAD MODULE OUTPUT DATA                                   *
*  SYSLIB:  LOAD LIBRARY CONTAINING MEMBER(S) TO BE PROCESSED.        *
*                                                                     *
* AUTHOR R THORNTON OCT 2000 - FEB 2002                               *
***********************************************************************
***********************************************************************
*                       PROGRAM INITIALIZATION                        *
*   SET UP BASE REGISTERS, CHAIN SAVE AREAS. OPEN FILES.              *
***********************************************************************
         USING LMODREAD,R3,R4,R5
         STM   R14,R12,12(R13)    SAVE CALLER'S REGS
         LR    R3,R15             SET UP BASE FIRST BASE REG
         L     R4,BASE2           SET UP SECOND BASE REGISTER
         L     R5,BASE3           SET UP THIRD BASE REGISTER
         LA    R15,MYSAVE         POINT TO MY REGISTER SAVE AREA
         ST    R15,8(R13)         SET LSA IN CALLER'S SAVE
         ST    R13,4(R15)         SET HSA IN MY SAVE AREA
         LR    R13,R15            SET UP SAVE AREA POINTER
         B     OPENS              BRANCH AROUND CONSTANTS
         DC    CL8'LMODREAD'      PROGRAM NAME IDENTIFIER
         DC    CL8'&SYSDATE'      ASSEMBLY DATE
         DC    CL8'&SYSTIME'      ASSEMBLY TIME
BASE2    DC    A(LMODREAD+4096)   2ND BASE REGISTER VALUE
BASE3    DC    A(LMODREAD+8192)   3RD BASE REGISTER VALUE
MYSAVE   DS    18F                MY REGISTER SAVE AREA
*********************************************************************
*  OPEN FILES FOR PROCESSING. GET BUFFER STORAGE.                   *
*********************************************************************
OPENS    OPEN  (OUTPUT1,OUTPUT,PRINT1,OUTPUT,READER1) OPEN FILES
         STORAGE OBTAIN,LENGTH=32768,ADDR=(R6),SP=0 GET BUFFER STORAGE
         ST    R6,BUFFERAD        SAVE ADDRESS OF BUFFER STORAGE
*********************************************************************
*        EXECRTN:                                                   *
*  EXECUTIVE CONTROL ROUTINE: PERFORMS THE PROCESSING ROUTINES THAT *
*  ACCOMPLISH THE PROGRAM'S WORK. FIRST, THE NEXT CONTROL RECORD IS *
*  READ. IF THERE IS ONE, PROCESSING ROUTINES ARE PERFORMED, OTHER- *
*  WISE THE PROGRAM IS TERMINATED.                                  *
*  FOR EACH CONTROL RECORD READ, AN INITIALIZATION ROUTINE CLEANS UP*
*  IN PREPARATION, THEN THE ESD, RLD, AND TEXT ROUTINES ARE CALLED. *
*********************************************************************
EXECRTN  BAS   R9,GETCNTL         READ NEXT CONTROL RECORD
         CLI   MORECNTL,0         GOT A CONTROL RECORD?
         BE    ECXIT              NO
         BAS   R9,NEWMODUL        YES, GO INITIALIZE
         CLI   NMERROR,0          ANY ERROR?
         BNE   EXECRTN            YES, GO TO NEXT CONTROL RECORD
         CLI   ERRNO,0            ANY ERROR?
         BNE   EXECRTN            YES, EXIT
         BAS   R9,GETNAMES        GET/PRINT ALL CSECT NAMES IN MEMBER
         CLI   ERRNO,0            ANY ERROR?
         BNE   EXECRTN            YES, EXIT
         CLI   NAMEFND,1          REQUESTED CSECT NAME FOUND?
         BE    EXESD              YES
         MVC   PRT(40),=CL40'REQUESTED CSECT NAME NOT FOUND IN MODULE'
         BAS   R9,PRINT           PRINT MESSAGE
EXESD    BAS   R9,ESD             GO PROCESS ESD ENTRIES
         BAS   R9,RLD             GO PROCESS RLD ENTRIES
         BAS   R9,TXT             GO PROCESS TEXT ENTRIES
         B     EXECRTN            LOOP THRU CONTROL RECORD SET
ECXIT    B     TERMINAT           GO TERMINATE PROCESSING
*********************************************************************
*        NEWMODUL:                                                  *
*  INITIALIZE FOR NEW MEMBER AND CSECT                              *
*********************************************************************
NEWMODUL ST    R9,NM9             SAVE RETURN ADDRESS
         MVI   NMERROR,0          CLEAR ERROR BYTE
         BAS   R9,STDIALOG        GO START THE BINDER DIALOG
         CLI   ERRNO,0            ANY ERROR?
         BNE   NMXIT              YES, EXIT
         BAS   R9,CRWRKMOD        GO CREATE THE WORKMOD
         CLI   ERRNO,0            ANY ERROR?
         BNE   NMXIT              YES, EXIT
         BAS   R9,INCLDMEM        GO "INCLUDE" THE MEMBER
NMXIT    L     R9,NM9             GET RETURN ADDRESS
         BR    R9                 EXIT
NM9      DC    A(0)               RETURN ADDRESS
*********************************************************************
*        ESD:                                                       *
*  PROCESS EXTERNAL SYMBOL DICTIONARY RECORDS. GETD CALLS ARE MADE  *
*  TO OBTAIN THE ESD DATA, THEN, THE PRTESD ROUTINE IS PERFORMED TO *
*  PRINT THE ESD INFORMATION.                                       *
*********************************************************************
ESD      ST    R9,ESD9            SAVE RETURN ADDRESS
         MVC   PRT(35),=CL35'*** ESD DATA RETURNED BY GETD CALL:'
         BAS   R9,PRINT           PRINT HEADER
         LA    ESD_BASE,ESDH_END-ESDH_START(IEWBESD_BASE) PT TO 1ST ENT
         IEWBUFF FUNC=INITBUF,TYPE=ESD INITIALIZE ESD BUFFER
         MVC   CRSRGETD,ZERO      RESET CURSOR
NEXTESD  IEWBIND FUNC=GETD,       READ ESD DATA FOR CSECT NAME         C    C
               RETCODE=RTRNGETD,      RETURN CODE                      C    C
               RSNCODE=RSNCGETD,      REASON CODE                      C    C
               WORKMOD=WKTOKEN,       WORKMOD TOKEN                    C    C
               CLASS=B_ESD,           IDENTIFY DATA TO BE READ         C    C
               SECTION=CSNAME,        CSECT NAME WITH LENGTH           C    C
               AREA=IEWBESD,          READ DATA INTO IEWBESD           C    C
               CURSOR=CRSRGETD,       CURSOR (0=FIRST CALL)            C    C
               COUNT=NBRGETD,         NUMBER ESD ITEMS READ INTO BUFFERC    C
               VERSION=3              BUFFER VERSION USED
         ST    IEWBESD_BASE,SVESBBAS  SAVE BASE ADDRESS
         ST    ESD_BASE,SVESBASE  SAVE BASE ADDRESS
         CLC   RSNCGETD,ZERO      GETD WAS SUCCESSFUL, FULL BUFFER?
         BNE   ESDTRY4            YES
         BAS   R9,PRTESD          GO PRINT ESD ENTRIES
         B     NEXTESD            GO GET NEXT BUFFER
ESDTRY4  CLC   RTRNGETD,FOUR      GETD SUCCESSFUL, LAST BUFFER?
         BNE   ESDERRS            NO
         BAS   R9,PRTESD          GO PRINT ESD ENTRIES
         B     ESDXIT             AND THEN EXIT
ESDERRS  MVI   ERRNO,5            NO, IDENTIFY ERROR CALLER
         MVC   ERRFUNC,=CL8'GETD    ' MOVE IEWBIND FUNCTION CODE
         UNPK  ERRETCD(9),RTRNGETD(5) MOVE RETURN CODE
         UNPK  ERRSNCD(9),RSNCGETD(5) MOVE REASON CODE
         BAS   R9,BINDERRS          PRINT ERROR MESSAGE
ESDXIT   L     R9,ESD9            GET RETURN ADDRESS
         BR    R9                 EXIT
ESD9     DC    A(0)               EXIT ADDRESS
         DROP  IEWBESD_BASE
         DROP  ESD_BASE
*********************************************************************
*        PRTESD:                                                    *
* PRINT ALL ESD ENTRIES IN THE BUFFER.                              *
*********************************************************************
PRTESD   ST    R9,PE9             SAVE RETURN ADDRESS
         L     R11,NBRGETD        NUMBER OF ESD ENTRIES IN BUFFER
         LTR   R11,R11            EMPTY SECTION, NO ESD'S?
         BNZ   PEPNT1ST           NO, GO PRINT THE ENTRIES
         MVC   PRT(39),=CL39'*** NO ESD ENTRIES FOUND FOR THIS CSECT'
         BAS   R9,PRINT           PRINT THE EMPTY MESSAGE
         B     PEXIT              AND LEAVE
PEPNT1ST L     R12,SVESBASE       POINT TO FIRST ESD ITEM IN BUFFER
         USING ESD_ENTRY,R12
PELOOP   MVC   ESDPRT1+1(132),BLANKS CLEAR TO BLANKS
         MVC   ESDPRT2+1(132),BLANKS CLEAR TO BLANKS
         MVC   EPTYPE,ESD_TYPE    MOVE ESD TYPE
         MVC   EPTYPQL,ESD_TYPE_QUAL MOVE ESD TYPE QUALIFIER
         MVC   EPNAMSP,ESD_NAME_SPACE MOVE ESD NAME SPACE
         MVC   EPSCOPE,ESD_SCOPE  ESD SCOPE
         MVC   EPNAME,BLANKS      CLEAR ESD NAME IN PRINT LINE
         SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,ESD_NAME_CHARS GET LENGTH OF NAME
         CH    R1,H8              OVER 8 BYTES?
         BNH   PEDED1             NO
         LA    R1,8               YES, FORCE TO 8
PEDED1   SH    R1,H1              MAKE LENGTH CODE
         BM    PEATTRS            BRANCH IF NEGATIVE LENGTH CODE
         L     R2,ESD_NAME_PTR    POINT TO ESD NAME
         EX    R1,PEMVNAME        MOVE NAME TO PRINT LINE
PEATTRS  UNPK  EPATTRS(3),ESD_SYMBOL_ATTR(2) MOVE ESD ATTRIBUTES
         TR    EPATTRS(2),TRCHAR-C'0'           TO PRINT LINE
         MVI   EPATTRS+2,C' '     CLEAR TRASH
         SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,ESD_RESIDENT_CHARS GET LENGTH OF NAME
         CH    R1,H8              OVER 8 BYTES?
         BNH   PEDED1A            NO
         LA    R1,8               YES, FORCE TO 8
PEDED1A  SH    R1,H1              MAKE LENGTH CODE
         BM    PELENGTH           BRANCH IF NEGATIVE LENGTH CODE
         L     R2,ESD_RESIDENT_PTR    POINT TO ESD NAME
         EX    R1,PEMVRES         MOVE NAME TO PRINT LINE
PELENGTH UNPK  EPLENGTH(9),ESD_LENG(5) MOVE ESD LENGTH
         TR    EPLENGTH,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPLENGTH+8,C' '    CLEAR TRASH
         UNPK  EPALIGN(3),ESD_ALIGN(2) MOVE ESD ALIGNMENT
         TR    EPALIGN,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPALIGN+2,C' '     CLEAR TRASH
         UNPK  EPAMODE(3),ESD_AMODE(2) MOVE ESD AMODE
         TR    EPAMODE,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPAMODE+2,C' '     CLEAR TRASH
         UNPK  EPRMODE(3),ESD_RMODE(2) MOVE ESD RMODE
         TR    EPRMODE,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPRMODE+2,C' '     CLEAR TRASH
         UNPK  EPRECFMT(5),ESD_RECORD_FMT(3) MOVE ESD RECORD FORMAT
         TR    EPRECFMT,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPRECFMT+4,C' '      CLEAR TRASH
         UNPK  EPLDFLGS(3),ESD_LOAD_FLAGS(2) MOVE ESD LOAD FLAGS
         TR    EPLDFLGS,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPLDFLGS+2,C' '      CLEAR TRASH
         UNPK  EPBNDFGS(3),ESD_BIND_FLAGS(2) MOVE ESD BIND FLAGS
         TR    EPBNDFGS,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPBNDFGS+2,C' '      CLEAR TRASH
         UNPK  EPBNDCTL(3),ESD_BIND_CNTL(2) MOVE ESD BIND CONTROL
         TR    EPBNDCTL,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPBNDCTL+2,C' '      CLEAR TRASH
         SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,ESD_XATTR_CLS_CHARS GET LENGTH OF XATTR CLASS NAME
         CH    R1,H8              OVER 8 BYTES?
         BNH   PEDED1B            NO
         LA    R1,8               YES, FORCE TO 8
PEDED1B  SH    R1,H1              MAKE LENGTH CODE
         BM    PEXTATTR           BRANCH IF NEGATIVE LENGTH CODE
         L     R2,ESD_XATTR_CLS_PTR   POINT TO XATTR CLASS NAME
         EX    R1,PEMVXCL         MOVE NAME TO PRINT LINE
PEXTATTR UNPK  EPXTOFF(9),ESD_XATTR_OFFSET(5) MOVE XATTR OFFFSET
         TR    EPXTOFF,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPXTOFF+8,C' '       CLEAR TRASH
         UNPK  EPSEGNO(5),ESD_SEGMENT(3) MOVE ESD OVERLAY SEGMENT NBR
         TR    EPSEGNO,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPSEGNO+4,C' '     CLEAR TRASH
         UNPK  EPREGION(5),ESD_REGION(3) MOVE ESD OVERLAY REGION NBR
         TR    EPREGION,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPREGION+4,C' '     CLEAR TRASH
         MVC   EPSIGN,ESD_SIGNATURE MOVE ESD INTERFACT SIGNATURE
         UNPK  EPAUTO(3),ESD_AUTOCALL(2) MOVE AUTOCALL SPECIFICATION
         TR    EPAUTO,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPAUTO+2,C' '      CLEAR TRASH
         UNPK  EPSTATE(3),ESD_STATUS(2) MOVE STATUS
         TR    EPSTATE,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPSTATE+2,C' '       CLEAR TRASH
         SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,ESD_TARGET_CHARS GET LENGTH TARGET CSECT NAME
         CH    R1,H8              OVER 8 BYTES?
         BNH   PEDED1C            NO
         LA    R1,8               YES, FORCE TO 8
PEDED1C  SH    R1,H1              MAKE LENGTH CODE
         BM    PERESCLS           BRANCH IF NEGATIVE LENGTH CODE
         L     R2,ESD_TARGET_PTR  POINT TO TARGET CSECT NAME
         EX    R1,PEMVTGT         MOVE NAME TO PRINT LINE
PERESCLS SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,ESD_RES_CLASS_CHARS LENGTH RESIDENT CLASS NAME
         CH    R1,H8              OVER 8 BYTES?
         BNH   PEDED1D            NO
         LA    R1,8               YES, FORCE TO 8
PEDED1D  SH    R1,H1              MAKE LENGTH CODE
         BM    PEELOFF            BRANCH IF NEGATIVE LENGTH CODE
         L     R2,ESD_RES_CLASS_PTR  POINT TO RESIDENT CLASS NAME
         EX    R1,PEMVRESC        MOVE NAME TO PRINT LINE
PEELOFF  UNPK  EPELOFF(9),ESD_ELEM_OFFSET(5) MOVE ELEMENT OFFSET
         TR    EPELOFF,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPELOFF+8,C' '       CLEAR TRASH
         UNPK  EPCLOFF(9),ESD_CLASS_OFFSET(5) MOVE CLASS OFFSET
         TR    EPCLOFF,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPCLOFF+8,C' '       CLEAR TRASH
         SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,ESD_ADA_LL    LENGTH OF ADA
         CH    R1,H8              OVER 8 BYTES?
         BNH   PEDED1E            NO
         LA    R1,8               YES, FORCE TO 8
PEDED1E  SH    R1,H1              MAKE LENGTH CODE
         BM    PEPRTY             BRANCH IF NEGATIVE LENGTH CODE
         L     R2,ESD_ADA_PTR     POINT TO ADA DATA
         EX    R1,PEMVADA         MOVE NAME TO PRINT LINE
PEPRTY   UNPK  EPPRTY(9),ESD_PRIORITY(5) MOVE BINDING SEQUENCE
         TR    EPPRTY,TRCHAR-C'0'       TO PRINT LINE
         MVI   EPPRTY+8,C' '      CLEAR TRASH
         MVC   PRTLINE,ESDPRT1    ESD DATA LINE 1 TO PRINT LINE
         BAS   R9,PRINT           PRINT FIRST LINE
         MVC   PRTLINE,ESDPRT2    ESD DATA LINE 2 TO PRINT LINE
         BAS   R9,PRINT           PRINT FIRST LINE
         L     R1,SVESBBAS        POINT TO ESD BUFFER
         USING IEWBESD,R1
         A     R12,ESDH_ENTRY_LENG MOVE TO NEXT ESD IN THIS SECTION
         DROP  R1
         BCT   R11,PELOOP         LOOP TO PRINT ALL ESD ITEMS
PEXIT    L     R9,PE9             GET RETURN CODE
         BR    R9                 EXIT
PE9      DC    A(0)               RETURN ADDRESS
PEMVNAME MVC   EPNAME(1),0(R2)    MOVE NAME TO PRINT
PEMVRES  MVC   EPRESNM(1),0(R2)   MOVE RESIDENT SECTION NAME TO PRINT
PEMVXCL  MVC   EPATTRCL(1),0(R2)  MOVE XATTR CLASS NAME TO PRINT
PEMVTGT  MVC   EPTGTNM(1),0(R2)   MOVE TARGET CSECT NAME TO PRINT
PEMVRESC MVC   EPRESCL(1),0(R2)   MOVE RESIDENT CLASS NAME TO PRINT
PEMVADA  MVC   EPADA(1),0(R2)     MOVE ASSOCIATED DATA TO PRINT
         DROP  R12
*********************************************************************
*        RLD:                                                       *
*  PROCESS RELOCATION DICTIONARY RECORDS. GETD CALLS ARE MADE TO    *
*  TO OBTAIN THE RLD DATA, THEN, THE PRTRLD ROUTINE IS PERFORMED TO *
*  PRINT THE RLD INFORMATION.                                       *
*********************************************************************
RLD      ST    R9,RLD9            SAVE RETURN ADDRESS
         MVC   PRT(35),=CL35'*** RLD DATA RETURNED BY GETD CALL:'
         BAS   R9,PRINT           PRINT HEADER
         LA    RLD_BASE,RLDH_END-RLDH_START(IEWBRLD_BASE) PT TO 1ST ENT
         IEWBUFF FUNC=INITBUF,TYPE=RLD INITIALIZE RLD BUFFER
         MVC   CRSRGETD,ZERO      RESET CURSOR
NEXTRLD  IEWBIND FUNC=GETD,       READ RLD DATA FOR CSECT NAME         C    C
               RETCODE=RTRNGETD,      RETURN CODE                      C    C
               RSNCODE=RSNCGETD,      REASON CODE                      C    C
               WORKMOD=WKTOKEN,       WORKMOD TOKEN                    C    C
               CLASS=B_RLD,           IDENTIFY DATA TO BE READ         C    C
               SECTION=CSNAME,        CSECT NAME WITH LENGTH           C    C
               AREA=IEWBRLD,          READ DATA INTO IEWBRLD           C    C
               CURSOR=CRSRGETD,       CURSOR (0=FIRST CALL)            C    C
               COUNT=NBRGETD,         NUMBER RLD ITEMS READ INTO BUFFERC    C
               VERSION=3              BUFFER VERSION USED
         ST    IEWBRLD_BASE,SVRLBBAS  SAVE BASE ADDRESS
         ST    RLD_BASE,SVRLBASE  SAVE BASE ADDRESS
         CLC   RSNCGETD,ZERO      GETD WAS SUCCESSFUL, FULL BUFFER?
         BNE   RLDTRY4            YES
         BAS   R9,PRTRLD          GO PRINT RLD ENTRIES
         B     NEXTRLD            GO GET NEXT BUFFER
RLDTRY4  CLC   RTRNGETD,FOUR      GETD SUCCESSFUL, LAST BUFFER?
         BNE   RLDERRS            NO
         BAS   R9,PRTRLD          GO PRINT RLD ENTRIES
         B     RLDXIT             AND THEN EXIT
RLDERRS  MVI   ERRNO,8            NO, IDENTIFY ERROR CALLER
         MVC   ERRFUNC,=CL8'GETD    ' MOVE IEWBIND FUNCTION CODE
         UNPK  ERRETCD(9),RTRNGETD(5) MOVE RETURN CODE
         UNPK  ERRSNCD(9),RSNCGETD(5) MOVE REASON CODE
         BAS   R9,BINDERRS          PRINT ERROR MESSAGE
RLDXIT   L     R9,RLD9            GET RETURN ADDRESS
         BR    R9                 EXIT
RLD9     DC    A(0)               EXIT ADDRESS
         DROP  IEWBRLD_BASE
         DROP  RLD_BASE
*********************************************************************
*        PRTRLD:                                                    *
* PRINT ALL RLD ENTRIES IN THE BUFFER.                              *
*********************************************************************
PRTRLD   ST    R9,PR9             SAVE RETURN ADDRESS
         L     R11,NBRGETD        NUMBER OF RLD ENTRIES IN BUFFER
         LTR   R11,R11            EMPTY SECTION, NO RLD'S?
         BNZ   PRPNT1ST           NO, GO PRINT THE ENTRIES
         MVC   PRT(39),=CL39'*** NO RLD ENTRIES FOUND FOR THIS CSECT'
         BAS   R9,PRINT           PRINT THE EMPTY MESSAGE
         B     PRXIT              AND LEAVE
PRPNT1ST L     R12,SVESBASE       POINT TO FIRST RLD ITEM IN BUFFER
         USING RLD_ENTRY,R12
PRLOOP   MVC   RLDPRT+1(132),BLANKS CLEAR TO BLANKS
         UNPK  RLTYPE(3),RLD_TYPE(2) MOVE RLD TYPE
         TR    RLTYPE(2),TRCHAR-C'0'    TO PRINT LINE
         MVI   RLTYPE+2,C' '      CLEAR TRASH
         UNPK  RLSTATUS(3),RLD_STATUS(2) MOVE RLD RELOCATION STATUS
         TR    RLSTATUS(2),TRCHAR-C'0'    TO PRINT LINE
         MVI   RLSTATUS+2,C' '      CLEAR TRASH
         SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,RLD_RESIDENT_CHARS GET LENGTH OF NAME
         CH    R1,H8              OVER 8 BYTES?
         BNH   PRDED1A            NO
         LA    R1,8               YES, FORCE TO 8
PRDED1A  SH    R1,H1              MAKE LENGTH CODE
         BM    PRLENGTH           BRANCH IF NEGATIVE LENGTH CODE
         L     R2,RLD_RESIDENT_PTR    POINT TO RLD NAME
         EX    R1,PRMVRES         MOVE NAME TO PRINT LINE
PRLENGTH UNPK  RLLENGTH(5),RLD_ADCON_LENG(3) MOVE RLD ADCON LENGTH
         TR    RLLENGTH,TRCHAR-C'0'       TO PRINT LINE
         MVI   RLLENGTH+4,C' '    CLEAR TRASH
         SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,RLD_RES_CLASS_CHARS LENGTH RESIDENT CLASS NAME
         CH    R1,H8              OVER 8 BYTES?
         BNH   PRDED1B            NO
         LA    R1,8               YES, FORCE TO 8
PRDED1B  SH    R1,H1              MAKE LENGTH CODE
         BM    PRELOFF            BRANCH IF NEGATIVE LENGTH CODE
         L     R2,RLD_RES_CLASS_PTR  POINT TO RESIDENT CLASS NAME
         EX    R1,PRMVRESC        MOVE NAME TO PRINT LINE
PRELOFF  UNPK  RLELOFF(9),RLD_RES_OFFSET(5) MOVE ELEMENT/PART OFFSET
         TR    RLELOFF,TRCHAR-C'0'       TO PRINT LINE
         MVI   RLELOFF+8,C' '       CLEAR TRASH
         UNPK  RLCLOFF(9),RLD_CLASS_OFFSET(5) MOVE CLASS OFFSET
         TR    RLCLOFF,TRCHAR-C'0'       TO PRINT LINE
         MVI   RLCLOFF+8,C' '       CLEAR TRASH
         UNPK  RLBDRY(3),RLD_ADCON_BDY(2) MOVE RLD ADCON BOUNDARY
         TR    RLBDRY(2),TRCHAR-C'0'    TO PRINT LINE
         MVI   RLBDRY+2,C' '      CLEAR TRASH
         UNPK  RLBNDATR(3),RLD_BIND_ATTR(2) MOVE RLD BOUNDARY STATUS
         TR    RLBNDATR,TRCHAR-C'0'       TO PRINT LINE
         MVI   RLBNDATR+2,C' '      CLEAR TRASH
         SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,RLD_XATTR_CLASS_CHARS GET XATTR CLASS NAME LENGTH
         CH    R1,H8              OVER 8 BYTES?
         BNH   PRDED1C            NO
         LA    R1,8               YES, FORCE TO 8
PRDED1C  SH    R1,H1              MAKE LENGTH CODE
         BM    PRXTATTR           BRANCH IF NEGATIVE LENGTH CODE
         L     R2,RLD_XATTR_CLASS_PTR   POINT TO XATTR CLASS NAME
         EX    R1,PRMVXCL         MOVE NAME TO PRINT LINE
PRXTATTR UNPK  RLXTOFF(9),RLD_XATTR_OFFSET(5) MOVE XATTR OFFFSET
         TR    RLXTOFF,TRCHAR-C'0'       TO PRINT LINE
         MVI   RLXTOFF+8,C' '       CLEAR TRASH
         UNPK  RLNAMSP(3),RLD_NAME_SPACE(2) MOVE RLD NAME SPACE
         TR    RLNAMSP(2),TRCHAR-C'0'    TO PRINT LINE
         MVI   RLNAMSP+2,C' '      CLEAR TRASH
         SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,RLD_TARGET_CHARS GET LENGTH OF TARGET NAME
         CH    R1,H8              OVER 8 BYTES?
         BNH   PRDED1D            NO
         LA    R1,8               YES, FORCE TO 8
PRDED1D  SH    R1,H1              MAKE LENGTH CODE
         BM    PRPART             BRANCH IF NEGATIVE LENGTH CODE
         L     R2,RLD_TARGET_PTR  POINT TO TARGET NAME
         EX    R1,PRMVTGT         MOVE NAME TO PRINT LINE
PRPART   SR    R1,R1              CLEAR FOR INSERT
         ICM   R1,3,RLD_RES_PART_LL GET LENGTH OF RESIDENT PART NAME
         CH    R1,H8              OVER 8 BYTES?
         BNH   PRDED1E            NO
         LA    R1,8               YES, FORCE TO 8
PRDED1E  SH    R1,H1              MAKE LENGTH CODE
         BM    PRPRINT            BRANCH IF NEGATIVE LENGTH CODE
         L     R2,RLD_TARGET_PTR  POINT TO TARGET NAME
         EX    R1,PRMVRPR         MOVE RESIDENT PART NAME TO PRINT LINE
PRPRINT  MVC   PRTLINE,RLDPRT     RLD DATA LINE TO PRINT LINE
         BAS   R9,PRINT           PRINT RLD DATA LINE
         L     R1,SVESBBAS        POINT TO RLD BUFFER
         USING IEWBRLD,R1
         A     R12,RLDH_ENTRY_LENG MOVE TO NEXT RLD IN THIS SECTION
         DROP  R1
         BCT   R11,PRLOOP         LOOP TO PRINT ALL RLD ITEMS
PRXIT    L     R9,PR9             GET RETURN CODE
         BR    R9                 EXIT
PR9      DC    A(0)               RETURN ADDRESS
PRMVRES  MVC   RLRESNM(1),0(R2)   MOVE RESIDENT SECTION NAME TO PRINT
PRMVRESC MVC   RLRESCL(1),0(R2)   MOVE RESIDENT CLASS NAME TO PRINT
PRMVXCL  MVC   RLATTRCL(1),0(R2)  MOVE XATTR CLASS NAME TO PRINT
PRMVTGT  MVC   RLTGTNM(1),0(R2)   MOVE TARGET SYMBOL NAME TO PRINT
PRMVRPR  MVC   RLRSPRT(1),0(R2)   MOVE RESIDENT PART NAME
         DROP  R12
*********************************************************************
*        TXT:                                                       *
*  PROCESS TEXT RECORDS                                             *
*********************************************************************
TXT      ST    R9,TXT9            SAVE RETURN ADDRESS
         MVC   PRT(36),=CL36'*** TEXT DATA RETURNED BY GETD CALL:'
         BAS   R9,PRINT           PRINT HEADER
         XC    PXDISP,PXDISP      SET DISPLACEMENT TO ZERO
         XC    PXLENGTH,PXLENGTH  SET WAITING TEXT BYTES TO ZERO
         LA    TXT_BASE,TXTH_END-TXTH_START(IEWBTXT_BASE) PT TO 1ST
         IEWBUFF FUNC=INITBUF,TYPE=TEXT INITIALIZE TEXT BUFFER
         MVC   CRSRGETD,ZERO      RESET CURSOR
NEXTEXT  IEWBIND FUNC=GETD,       READ TEXT DATA FOR CSECT NAME        C    C
               RETCODE=RTRNGETD,      RETURN CODE                      C    C
               RSNCODE=RSNCGETD,      REASON CODE                      C    C
               WORKMOD=WKTOKEN,       WORKMOD TOKEN                    C    C
               CLASS=B_TXT,           IDENTIFY DATA TO BE READ         C    C
               SECTION=CSNAME,        CSECT NAME WITH LENGTH           C    C
               AREA=IEWBTXT,          READ DATA INTO IEWBRLD           C    C
               CURSOR=CRSRGETD,       CURSOR (0=FIRST CALL)            C    C
               COUNT=NBRGETD,         NUMBER TXT ITEMS READ INTO BUFFERC    C
               VERSION=3              BUFFER VERSION USED
         ST    IEWBTXT_BASE,SVTXBBAS  SAVE BASE ADDRESS
         ST    TXT_BASE,SVTXBASE  SAVE BASE ADDRESS
         CLC   RSNCGETD,ZERO      GETD WAS SUCCESSFUL, FULL BUFFER?
         BNE   TXTTRY4            YES
         BAS   R9,PRTTEXT         GO PRINT TEXT ENTRIES
         B     NEXTEXT            GO GET NEXT BUFFER
TXTTRY4  CLC   RTRNGETD,FOUR      GETD SUCCESSFUL, LAST BUFFER?
         BNE   TXTERRS            NO
         BAS   R9,PRTTEXT         GO PRINT RLD ENTRIES
         B     TXTXIT             AND THEN EXIT
TXTERRS  MVI   ERRNO,9            NO, IDENTIFY ERROR CALLER
         MVC   ERRFUNC,=CL8'GETD    ' MOVE IEWBIND FUNCTION CODE
         UNPK  ERRETCD(9),RTRNGETD(5) MOVE RETURN CODE
         UNPK  ERRSNCD(9),RSNCGETD(5) MOVE REASON CODE
         BAS   R9,BINDERRS          PRINT ERROR MESSAGE
         DROP  IEWBTXT_BASE,TXT_BASE
TXTXIT   L     R9,TXT9            GET RETURN ADDRESS
         BR    R9                 EXIT
TXT9     DC    A(0)               EXIT ADDRESS
*********************************************************************
*        PRTTEXT:                                                   *
*  PRINT THE TEXT FOR THE SPECIFIED CSECT                           *
*********************************************************************
PRTTEXT  ST    R9,PX9             SAVE RETURN ADDRESS
         L     R11,NBRGETD        NUMBER OF TXT BYTES IN BUFFER
         LTR   R11,R11            EMPTY SECTION, NO TEXT?
         BNZ   PXPNT1ST           NO, GO PRINT THE TEXT
         MVC   PRT(39),=CL39'*** NO TXT ENTRIES FOUND FOR THIS CSECT'
         BAS   R9,PRINT           PRINT THE EMPTY MESSAGE
         B     PXXIT              AND LEAVE
PXPNT1ST L     R12,SVTXBASE       POINT TO FIRST TXT BYTE IN BUFFER
         USING TXT_ENTRY,R12
         CLC   PXDISP,ZERO        FIRST TIME HERE FOR THIS CSECT?
         BE    PXLOOP             YES
PXNOT1ST CLC   PXLENGTH,H0        ANY BYTES AWAITING PRINT?
         BE    PXLOOP             NO
         LA    R1,32              COMPUTE BYTES NEEDED TO
         SH    R1,PXLENGTH           FILL WAITING BUFFER
         BNP   PXN1LT32           BRANCH IF NOT ENOUGH
         BCTR  R1,0               COMPUTE MOVE LENGTH
         LA    R2,PXDATA          POINT TO WAITING BUFFER
         AH    R2,PXLENGTH        POINT TO NEXT BYTE IN WAITING BUFFER
         EX    R1,PXMVN1A         MOVE TO FILL AWAITING BUFFER
         MVC   PXLENGTH,H32       SET LENGTH IN WAITING BUFFER
         B     PXFORMAT           GO FORMAT TEXT
PXN1LT32 LR    R1,R11             COPY NBR BYTES REMAINING
         BCTR  R1,0               COMPUTE MOVE LENGTH
         LA    R2,PXDATA          POINT TO WAITING BUFFER
         AH    R2,PXLENGTH        POINT TO NEXT BYTE IN WAITING BUFFER
         EX    R1,PXMVN1A         MOVE REMAINING BYTES TO WAITING BFR
         LR    R1,R11             COMPUTE LENGTH
         AH    R1,PXLENGTH           OF DATA IN
         STH   R1,PXLENGTH              WAITING BUFFER
         B     PXLT32ND           CONTINUE
PXLOOP   CH    R11,H32            32 BYTES LEFT IN BUFFER?
         BL    PXLT32             YES
         MVC   PXLENGTH,H32       SET WAITING LENGTH TO 32
         MVC   PXDATA,0(R12)      MOVE NEXT 32 BYTES TO WAITING BFR
         B     PXFORMAT           GO FORMAT FOR PRINT
PXLT32   EQU   *                  LESS  THAN 32 BYTES REMAIN TO PRINT
         STH   R11,PXLENGTH       STORE NBR BYTES REMAINING
         BCTR  R11,0              COMPUTE LENGTH CODE
         EX    R11,PXMVTXT        MOVE TEXT INTO BUFFER
PXLT32ND CLC   RTRNGETD,ZERO      ANY MORE TEXT IN THIS CSECT?
         BE    PXXIT              YES
PXFORMAT MVC   TXTPRT,BLANKS      CLEAR FOR PRINT FORMAT
         UNPK  TXDISPL(7),PXDISP+1(4) UNPACK DISPLACEMENT TO
         TR    TXDISPL,TRCHAR-C'0'     MAKE IT PRINTABLE
         MVI   TXDISPL+6,C' '     CLEAR GARBAGE
         LH    R1,PXLENGTH        GET LENGTH OF WAITING TEXT
         BCTR  R1,0               GET LENGTH CODE
         EX    R1,PXMOVECH        MOVE CHARACTER DATA
         EX    R1,PXTRANCH        TRANSLATE CHARACTER DATA
         MVI   TXDLM1,C'*'        DELIMIT CHARACTER DATA
         MVI   TXDLM2,C'*'        DELIMIT CHARACTER DATA
         LA    R1,TXTPRTBL        POINT TO TXT FORMAT TABLE
         LH    R2,PXLENGTH        GET LENGTH TO PRINT
PXPRTLUP LM    R9,R10,0(R1)       GET PRINT, WAITING POINTERS
         CH    R2,H4              AT LEAST FOUR BYTES LEFT?
         BNL   PXFORM4            YES
         CH    R2,H3              NO, 3 BYTES LEFT?
         BE    PXFORM3            YES
         CH    R2,H2              NO, 3 BYTES LEFT?
         BE    PXFORM2            YES
         CH    R2,H1              NO, 3 BYTES LEFT?
         BE    PXFORM1            YES
         B     PXPRINT            FINISHED, GO PRINT
PXFORM4  UNPK  0(9,R9),0(5,R10)   UNPACK TO PRINT
         TR    0(8,R9),TRCHAR-C'0'  AND MAKE PRINTABLE
         MVI   8(R9),C' '         CLEAR GARBAGE
         SH    R2,H4              DEDUCT 4 FROM COUNT
         BNP   PXPRINT            GO PRINT IF ALL THRU
         LA    R1,8(R1)           STEP TO NEXT TABLE ENTRY
         B     PXPRTLUP           LOOP TO PRINT WAITING TEXT
PXFORM3  UNPK  0(7,R9),0(4,R10)   UNPACK TO PRINT
         TR    0(6,R9),TRCHAR-C'0'  AND MAKE PRINTABLE
         MVI   6(R9),C' '         CLEAR GARBAGE
         B     PXPRINT            GO PRINT
PXFORM2  UNPK  0(5,R9),0(3,R10)   UNPACK TO PRINT
         TR    0(4,R9),TRCHAR-C'0'  AND MAKE PRINTABLE
         MVI   4(R9),C' '         CLEAR GARBAGE
         B     PXPRINT            GO PRINT
PXFORM1  UNPK  0(3,R9),0(2,R10)   UNPACK TO PRINT
         TR    0(2,R9),TRCHAR-C'0'  AND MAKE PRINTABLE
         MVI   2(R9),C' '         CLEAR GARBAGE
PXPRINT  MVC   PRTLINE,TXTPRT     MOVE TXT DATA PRINT LINE
         BAS   R9,PRINT           PRINT TXT DATA LINE
         AH    R12,PXLENGTH       STEP TO NEXT TXT BYTE TO PRINT
         L     R1,PXDISP          UPDATE
         AH    R1,PXLENGTH          DISPLACEMENT
         ST    R1,PXDISP               TO NEXT TXT BYTE
         MVC   PXDATA,BLANKS      CLEAR WAITING BUFFER
         SH    R11,PXLENGTH       DEDUCT BYTES JUST PRINTED
         BP    PXLOOP             LOOP TO PRINT ALL TEXT IN BUFFER
         MVC   PXLENGTH,H0        ZERO OUT WAITING BUFFER COUNT
PXXIT    L     R9,PX9             GET RETURN ADDRESS
         BR    R9                 EXIT
PXMVTXT  MVC   PXDATA(1),0(R12)   MOVE DATA BYTES TO AWAITING PRINT
PXMVN1A  MVC   0(1,R2),0(R12)     MOVE TO FILL WAITING BUFFER
PXMOVECH MVC   TXCHARS(1),PXDATA  MOVE AND TRANSLATE
PXTRANCH TR    TXCHARS(1),PRTONLY CHARACTER DATA
PX9      DC    A(0)               RETURN ADDRESS
*********************************************************************
*        GETCNTL:                                                   *
*  READ NEXT CONTROL RECORD AND SAVE THE MEMBER AND CSECT NAMES.    *
*********************************************************************
GETCNTL  ST    R9,GC9             SAVE RETURN ADDRESS
GCGET    GET   READER1,CTLRECD    READ NEXT CONTROL RECORD
         MVC   PRT(20),=CL20'CONTROL RECORD ===> '
         MVC   PRT+20(80),CTLRECD CONTROL RECORD TO PRINT LINE
         BAS   R9,PRINT           PRINT THE CONTROL RECORD
         CLI   CTLRECD,C'*'       COMMENT RECORD?
         BE    GCGET              YES, DROP IT
         MVC   MEMBER,CRMEMBER    MEMBER NAME TO PARAMETER FIELD
         LA    R12,8              SET MAX NAME LENGTH
         LA    R11,MEMBER+7       POINT TO LAST BYTE
GCMLCKBK CLI   0(R11),C' '        AT A BLANK?
         BNE   GCML               NO
         BCTR  R12,0              DEDUCT 1 FROM LENGTH
         BCT   R11,GCMLCKBK       LOOP
GCML     STH   R12,MEMLENG        STORE MEMBER NAME LENGTH
         SH    R12,H1             COMPUTE LENGTH CODE
         BM    GCBAD              NEGATIVE, ERROR
         EX    R12,GCVALMEM       TEST VALID NAME CHARACTERS
         BNZ   GCBAD              BRANCH IF INVALID
         MVC   CSECT,CRCSECT      CSECT NAME TO PARAMETER FIELD
         LA    R12,8              SET MAX NAME LENGTH
         LA    R11,CSECT+7        POINT TO LAST BYTE
GCCLCKBK CLI   0(R11),C' '        AT A BLANK?
         BNE   GCCL               NO
         BCTR  R12,0              DEDUCT 1 FROM LENGTH
         BCT   R11,GCCLCKBK       LOOP
GCCL     STH   R12,CSLENG         STORE CSECT NAME LENGTH
         SH    R12,H1             COMPUTE LENGTH CODE
         BM    GCBAD              NEGATIVE, ERROR
         EX    R12,GCVALCSE       TEST VALID NAME CHARACTERS
         BZ    GCXIT              GO TO EXIT
GCBAD    MVC   PRTLINE,BADCNTL    MOVE ERROR MESSAGE
         MVI   PRTCC,C'0'         SET DOUBLESPACING
         BAS   R9,PRINT           GO PRINT THE LINE
         MVC   PRTLINE(80),CTLRECD MOVE INVALID CONTROL RECORD
         BAS   R9,PRINT           PRINT BAD CONTROL RECORD
         MVI   PRTCC,C'0'         SET DOUBLESPACING
         B     GCGET              GO GET NEXT CONTROL RECORD
GCENDCTL MVI   MORECNTL,0         INDICATE NO MORE CONTROL RECORDS
GCXIT    L     R9,GC9             GET RETURN ADDRESS
         BR    R9                 EXIT
GCVALMEM TRT   MEMBER(1),TSTVALID EXECUTED SCAN FOR VALID CHARACTERS
GCVALCSE TRT   CSECT(1),TSTVALID  EXECUTED SCAN FOR VALID CHARACTERS
GC9      DC    A(0)               RETURN ADDRESS
*********************************************************************
*        PRINT:                                                     *
*  PRINT THE DATA IN PRTLINE AND CLEAR IT FOR THE NEXT LINE.        *
*********************************************************************
PRINT    ST    R9,PT9             SAVE RETURN ADDRESS
         PUT   PRINT1,PRTLINE     PRINT DATA LINE
         MVC   PRTLINE,BLANKS     CLEAR PRINT LINE TO BLANKS
         L     R9,PT9             GET RETURN ADDRESS
         BR    R9                 EXIT
PT9      DC    A(0)               RETURN ADDRESS
***********************************************************************
*        STDIALOG:                                                    *
*    START DIALOG: THE STARTD CALL ESTABLISHES A DIALOG WITH THE      *
*    BINDER. IT IS ALWAYS REQUIRED AND SETS THE DIALOG TOKEN FOR USE  *
*    IN SUBSEQUENT BINDER CALLS. THE DIALOG TOKEN SHOULD BE SET TO    *
*    A DOUBLEWORD OF ZERO BEFORE ITS FIRST USAGE.                     *
***********************************************************************
STDIALOG ST    R9,SD9             SAVE RETURN ADDRESS
         MVI   ERRNO,0            CLEAR ERROR INDICATER
         MVC   DTOKEN,DZERO       CLEAR DIALOG TOKEN
         IEWBIND FUNC=STARTD,     INITIATE THE BINDER DIALOG           C    C
               RETCODE=RTRNSTR,       RETURN CODE                      C    C
               RSNCODE=RSNCSTR,       REASON CODE                      C    C
               DIALOG=DTOKEN,         DIALOG TOKEN                     C    C
               VERSION=3              USE VERSION 3 BUFFERS
         CLC   RSNCSTR,ZERO       CHECK THE REASON CODE
         BE    SDXIT              EXIT IF ZERO
         MVI   ERRNO,1            IDENTIFY BINDERRS CALLER
         MVC   ERRFUNC,=CL8'STARTD  ' MOVE IEWBIND FUNCTION CODE
         UNPK  ERRETCD(9),RTRNSTR(5) MOVE RETURN CODE
         UNPK  ERRSNCD(9),RSNCSTR(5) MOVE REASON CODE
         BAS   R9,BINDERRS        GO WRITE ERROR MESSAGE
SDXIT    L     R9,SD9             GET RETURN ADDRESS
         BR    R9                 EXIT
SD9      DC    A(0)               RETURN ADDRESS
***********************************************************************
*        CRWRKMOD:                                                    *
*    CREATE A WORKMOD WITH INTENT ACCESS. THIS LOGIC CREATES A BINDER *
*    WORKMOD WITH INTENT=ACCESS. THE DIALOG TOKEN, DTOKEN, IS A REQ-  *
*    UIRED INPUT PARAMETER. THE WORKMOD TOKEN SHOULD BE INITIALIZED TO*
*    A DOUBLEWORD OF ZERO PRIOR TO THE CREATEW CALL.                  *
***********************************************************************
CRWRKMOD ST    R9,CM9             SAVE RETURN ADDRESS
         MVC   WKTOKEN,DZERO      CLEAR WORKMOD TOKEN
         IEWBIND FUNC=CREATEW,    CREATE THE WORKMOD                   C    C
               RETCODE=RTRNCRE,      RETURN CODE                       C    C
               RSNCODE=RSNCCRE,      REASON CODE                       C    C
               WORKMOD=WKTOKEN,      WORKMOD TOKEN                     C    C
               DIALOG=DTOKEN,        DIALOG TOKEN                      C    C
               INTENT=ACCESS,        WHAT WE NEED IT FOR               C    C
               VERSION=3             USE VERSION 3 BUFFERS
         CLC   RSNCCRE,ZERO       CHECK THE REASON CODE
         BE    CMXIT              EXIT IF ZERO
         MVI   ERRNO,2            IDENTIFY ERROR CALLER
         MVC   ERRFUNC,=CL8'CREATEW ' MOVE IEWBIND FUNCTION CODE
         UNPK  ERRETCD(9),RTRNCRE(5) MOVE RETURN CODE
         UNPK  ERRSNCD(9),RSNCCRE(5) MOVE REASON CODE
         BAS   R9,BINDERRS        GO PRINT ERROR MESSAGES
CMXIT    L     R9,CM9             GET RETURN ADDRESS
         BR    R9                 EXIT
CM9      DC    A(0)               RETURN ADDRESS
***********************************************************************
*        INCLDMEM:                                                    *
*    INCLUDE THE MEMBER SPECIFIED IN THE CONTROL RECORD               *
*    FROM THE LIBRARY SPECIFIED BY THE SYSLIB DD STATEMENT.           *
***********************************************************************
INCLDMEM ST    R9,IM9             SAVE RETURN ADDRESS
         IEWBIND FUNC=INCLUDE,    INCLUDE THE MEMBER TO PROCESS        C    C
               RETCODE=RTRNINCL,     RETURN CODE                       C    C
               RSNCODE=RSNCINCL,     REASON CODE                       C    C
               WORKMOD=WKTOKEN,      WORKMOD TOKEN                     C    C
               INTYPE=NAME,          WE'RE SUPPLYING MEMBER NAME       C    C
               DDNAME=SYSLIB,        USE DDNAME=SYSLIB TO FIND MEMBER  C    C
               MEMBER=MEMNAME,       MEMBER NAME WITH LENGTH           C    C
               VERSION=3 USE VERSION 3 BUFFERS
         CLC   RSNCINCL,ZERO      CHECK THE REASON CODE
         BE    IMXIT              EXIT IF ZERO
         MVI   ERRNO,3            IDENTIFY ERROR CALLER
         MVC   ERRFUNC,=CL8'INCLUDE ' MOVE IEWBIND FUNCTION CODE
         UNPK  ERRETCD(9),RTRNINCL(5) MOVE RETURN CODE
         UNPK  ERRSNCD(9),RSNCINCL(5) MOVE REASON CODE
         BAS   R9,BINDERRS        GO PRINT ERROR MESSAGE
IMXIT    L     R9,IM9             GET RETURN ADDRESS
         BR    R9                 EXIT
IM9      DC    A(0)               RETURN ADDRESS
***********************************************************************
*        GETNAMES:                                                    *
*    GET ALL SECTION NAMES FROM WORKMOD. FIRST, ADDRESSABILITY TO THE *
*    FIRST ENTRY IS PROVIDED IN R7. EACH GETN CALL RETRIEVES NAMES OF *
*    SECTIONS IN THE SPECIFIED MEMBER. THESE NAMES ARE RETURNED IN THE*
*    NAMES BUFFER, IEWBBNL, AND COUNTN IS SET TO THE NUMBER OF NAMES  *
*    RETURNED. TCOUNT IS SET TO THE TOTAL NUMBER OF NAMES IN THE      *
*    MODULE, REGARDLESS OF THE SIZE OF THE BUFFER. A RETURN CODE OF 4 *
*    INDICATES THAT ALL NAMES HAVE BEEN RETURNED IN THE BUFFER AND    *
*    THAT ADDITIONAL GETN CALLS ARE UNNECESSARY. WHEN THE NAME IN THE *
*    CONTROL RECORD IS FOUND, RETURN TO CALLER.                       *
***********************************************************************
GETNAMES ST    R9,GN9             SAVE RETURN ADDRESS
         MVI   NAMEFND,0          CLEAR THE NAME FOUND SWITCH
         MVC   CRSRGETN,ZERO      SET STARTING PLACE FOR GETN
         MVC   PRT(34),=CL34'CSECT NAMES RETURNED BY GETN CALL:'
         BAS   R9,PRINT           PRINT HEADER
GNNEXT   LA    BNL_BASE,BNLH_END-BNLH_START(IEWBBNL_BASE) PT TO 1ST ENT
         IEWBUFF FUNC=INITBUF,TYPE=NAME INITIALIZE NAME BUFFER
         IEWBIND FUNC=GETN,       READ CSECT (SECTION) NAMES IN MEMBER C    C
               RETCODE=RTRNGETN,     RETURN CODE                       C    C
               RSNCODE=RSNCGETN,     REASON CODE                       C    C
               WORKMOD=WKTOKEN,      WORKMOD TOKEN                     C    C
               AREA=IEWBBNL,         RETURN RESULTS IN IEWBBNL         C    C
               CURSOR=CRSRGETN,      CURSOR POINTER (ZERO FIRST TIME)  C    C
               COUNT=NBRGETN,        NUMBER NAMES GOTTEN IN BUFFER     C    C
               TCOUNT=TOTLGETN,      TOTAL NBR NAMES IN MEMBER         C    C
               NTYPE=SECTION,        RETURN SECTION (NOT CLASS) NAMES  C    C
               VERSION=3             USE VERSION 3 BUFFERS
         ST    IEWBBNL_BASE,SVBBBASE SAVE IEWBBNL BASE ADDRESS
         ST    BNL_BASE,SVBNBASE  SAVE BNL_ENTRY ADDRESS
         CLC   RSNCGETN,ZERO      GETN RC=0?
         BNE   GNCK4              NO
         BAS   R9,PRTNAMES        YES, GO PRINT THE NAMES
         CLI   ERRNO,0            ANY ERRORS?
         BE    GNNEXT             NO, GO GET NEXT BUFFER FULL
         B     GNXIT              YES, EXIT
GNCK4    CLC   RTRNGETN,FOUR      DO WE HAVE ALL THE NAMES
         BNE   GNMV4              NO
         BAS   R9,PRTNAMES        YES, GO PRINT THE NAMES
         B     GNXIT              AND EXIT
GNMV4    MVI   ERRNO,4            IDENTIFY ERROR CALLER
         MVC   ERRFUNC,=CL8'GETN    ' MOVE IEWBIND FUNCTION CODE
         UNPK  ERRETCD(9),RTRNGETN(5) MOVE RETURN CODE
         UNPK  ERRSNCD(9),RSNCGETN(5) MOVE REASON CODE
         BAS   R9,BINDERRS        GO PRINT ERROR MESSAGE
         DROP  IEWBBNL_BASE,BNL_BASE
GNXIT    L     R9,GN9             GET RETURN ADDRESS
         BR    R9                 EXIT
GN9      DC    A(0)               RETURN ADDRESS
***********************************************************************
*        PRTNAMES:                                                    *
*    PROCESS THE NAME DATA RETURNED BY GETN. IF THE CSECT NAME IN THE *
*    CONTROL RECORD IS FOUND, SET THE NAME FOUND FLAG. FOR EACH NAME  *
*    FOUND, PRINT THE NAME DATA FROM THE BUFFER.                      *
***********************************************************************
PRTNAMES ST    R9,PN9             SAVE RETURN ADDRESS
         L     R10,NBRGETN        NUMBER OF CSECTS
         L     R11,SVBNBASE       POINT TO BNL_ENTRY
         USING BNL_ENTRY,R11
PNLOOP   L     R12,BNL_NAME_PTR   POINT TO CSECT NAME
         LH    R2,BNL_NAME_CHARS  GET NAME LENGTH
         BCTR  R2,0               COMPUTE LENGTH CODE
         EX    R2,PNMVNAME        MOVE NAME TO PRINT
         CLI   PRT+4,0            PRIVATE CSECT?
         BNE   PNCMPAR            NO
         MVC   PRT(8),=CL8'$PRIVATE' PRIVATE (UNNAMED) CSECT
         B     PNPRNT             CONTINUE
PNCMPAR  EX    R2,PNCKNAME        SAME NAME AS REQUESTED CSECT?
         BNE   PNPRNT             NO
         LA    R2,1(R2)           COMPUTE ACTUAL LENGTH OF NAME
         CH    R2,CSLENG          SAME LENGTH?
         BNE   PNPRNT             NO
         MVI   NAMEFND,1          SET THE NAME FOUND SWITCH
PNPRNT   BAS   R9,PRINT           GO PRINT THE CSECT NAME
         L     R1,SVBBBASE        POINT TO BUFFER
         USING IEWBBNL,R1
         A     R11,BNLH_ENTRY_LENG MOVE TO NEXT SECTION NAME
         DROP  R1
         BCT   R10,PNLOOP         LOOP THRU NAME LIST
PNXIT    L     R9,PN9             GET RETURN ADDRESS
         BR    R9                 EXIT
PNMVNAME MVC   PRT+4(1),0(R12)    EXECUTED CSECT NAME MOVE
PNCKNAME CLC   0(1,R12),CSECT     EXECUTED CSECT NAME COMPARE
PN9      DC    A(0)               RETURN ADDRESS
         DROP  R11
***********************************************************************
*        DELETEW:                                                     *
*     DONE PROCESSING - DELETE WORKMOD. DELETEW REMOVES THE WORKMOD   *
*     FROM BINDER STORAGE. PROTECT=YES, THE DEFAULT, MERELY INDICATES *
*     THAT THE DELETE SHOULD FAIL IF THE WORKMOD HAS BEEN ALTERED BY  *
*     THE DIALOG. SINCE INTENT=ACCESS, NO ALTERATION WAS POSSIBLE, AND*
*     PROTECT=YES IS INEFFECTIVE.                                     *
***********************************************************************
DELETEW  ST    R9,DW9             SAVE THE RETURN ADDRESS
         IEWBIND FUNC=DELETEW,    DELETE THE WORKMOD                   C    C
               RETCODE=RTRNDEL,       RETURN CODE                      C    C
               RSNCODE=RSNCDEL,       REASON CODE                      C    C
               WORKMOD=WKTOKEN,       WORKMOD TOKEN                    C    C
               PROTECT=YES,           PROTECT AGAINST UPDATE           C    C
               VERSION=3              USE VERSION 3 BUFFERS
         CLC   RSNCDEL,ZERO       ANY ERROR?
         BE    DWXIT              BRANCH IF NO ERROR
         MVI   ERRNO,6            IDENTIFY ERROR CALLER
         MVC   ERRFUNC,=CL8'DELETEW ' MOVE IEWBIND FUNCTION CODE
         UNPK  ERRETCD(9),RTRNDEL(5) MOVE RETURN CODE
         UNPK  ERRSNCD(9),RSNCDEL(5) MOVE REASON CODE
         BAS   R9,BINDERRS        GO PRINT ERROR MESSAGE
DWXIT    L     R9,DW9             GET RETURN ADDRESS
         BR    R9                 RETURN TO CALLER
DW9      DC    A(0)               RETURN ADDRESS
***********************************************************************
*        ENDDLG:                                                      *
*     END DIALOG. ENDD ENDS THE DIALOG BETWEEN THE PROGRAM AND THE    *
*     BINDER, RELEASING ANY REMAINING RESOURCES, CLOSING ALL FILES,   *
*     AND RESETTING THE DIALOG TOKEN TO THE NULL VALUE.               *
***********************************************************************
ENDDLG   ST    R9,ED9             SAVE RETURN ADDRESS
         IEWBIND FUNC=ENDD,       END THE DIALOG                       C    C
               RETCODE=RTRNENDD,      RETURN CODE                      C    C
               RSNCODE=RSNCENDD,      REASON CODE                      C    C
               DIALOG=DTOKEN,         DIALOG TOKEN                     C    C
               VERSION=3              VERSION CODE
         CLC   RSNCENDD,ZERO      ANY ERROR?
         BE    EDXIT              BRANCH IF NO ERROR
         MVI   ERRNO,7            IDENTIFY ERROR CALLER
         MVC   ERRFUNC,=CL8'ENDD    ' MOVE IEWBIND FUNCTION CODE
         UNPK  ERRETCD(9),RTRNENDD(5) MOVE RETURN CODE
         UNPK  ERRSNCD(9),RSNCENDD(5) MOVE REASON CODE
         BAS   R9,BINDERRS        GO PRINT ERROR MESSAGE
EDXIT    L     R9,ED9             GET RETURN ADDRESS
         BR    R9                 RETURN TO CALLER
ED9      DC    A(0)               RETURN ADDRESS
***********************************************************************
*     BINDERRS:                                                       *
*  WRITE ERROR MESSAGES FOR IEWBIND/IEWBUFF MACRO ERRORS              *
***********************************************************************
BINDERRS ST    R9,EE9             SAVE RETURN ADDRESS
         TR    ERRETCD(8),TRCHAR-C'0' MAKE RETURN CODE PRINTABLE
         MVI   ERRETCD+8,C','     REPLACE GARBAGE
         TR    ERRSNCD(8),TRCHAR-C'0' MAKE REASON CODE PRINTABLE
         MVI   ERRSNCD+8,C' '     REPLACE GARBAGE
         MVC   PRT,BINDERR        BIND ERROR MESSAGE TO PRINT LINE
         BAS   R9,PRINT           PRINT ERROR MESSAGE
EESETCD  CLC   RETCODE,R15RC      HIGHER RETURN CODE?
         BNH   EEXIT              NO
         MVC   R15RC,RETCODE      SET THE REASON CODE TO R15
EEXIT    L     R9,EE9             GET RETURN ADDRESS
         BR    R9                 RETURN TO CALLER
EE9      DC    A(0)               RETURN ADDRESS
***********************************************************************
*        TERMINAT:                                                    *
*  TERMINATE PROCESSING. CLOSE FILES, RESTORE CALLER'S REGS, AND      *
*  RETURN CONTROL.                                                    *
***********************************************************************
TERMINAT L     R6,BUFFERAD        GET ADDRESS OF BUFFER STORAGE
         STORAGE RELEASE,LENGTH=32768,ADDR=(R6),SP=0 GET BUFFER STORAGE
TERM2    CLOSE (READER1,,PRINT1,,OUTPUT1) CLOSE FILES
         L     R13,4(R13)         POINT TO CALLER'S SAVE AREA
         L     R14,12(R13)        GET RETURN ADDRESS
         L     R15,R15RC          GET PROGRAM RETURN CODE
         LM    R0,R12,20(R13)     RESTORE CALLER'S REGS 0-12
         BR    R14                RETURN TO CALLER
***********************************************************************
*                       PROGRAM CONSTANTS                             *
***********************************************************************
DZERO    DC    2F'0'
R15RC    DC    F'0'               END OF JOB RETURN CODE
ZERO     DC    F'0'
FOUR     DC    F'4'
EIGHT    DC    F'8'
BUFFERAD DC    A(0)               ADDRESS OF BUFFER FOR IEWBUFF
SVBBBASE DC    A(0)               SAVE IEWBBNL BASE ADDRESS
SVBNBASE DC    A(0)               SAVE BNL_ENTRY BASE
SVESBBAS DC    A(0)               SAVE IEWBESD BASE ADDRESS
SVESBASE DC    A(0)               SAVE ESD_ENTRY BASE
SVRLBBAS DC    A(0)               SAVE IEWBRLD BASE ADDRESS
SVRLBASE DC    A(0)               SAVE RLD_ENTRY BASE
SVTXBBAS DC    A(0)               ADDRESS OF IEWBTXT
SVTXBASE DC    A(0)               CURRENT TEXT ADDRESS
H0       DC    H'0'               CONSTANT 0
H1       DC    H'1'               CONSTANT 1
H2       DC    H'2'               CONSTANT 2
H3       DC    H'3'               CONSTANT 3
H4       DC    H'4'               CONSTANT 4
H8       DC    H'8'               CONSTANT 8
H9       DC    H'9'               CONSTANT 9
H32      DC    H'32'              CONSTANT 32
NMERROR  DC    X'00'              NEWMODUL ERROR INDICATOR
NAMEFND  DC    X'00'              NAME FOUND SWITCH
ERRNO    DC    X'00'              BINDERRS CALLER ID
PXDISP   DC    F'0'               TEXT DISPLACEMENT
PXLENGTH DC    H'0'               TEXT BYTES IN PXDATA
PXDATA   DC    CL32' '            TEXT BYTES TO BE PRINTED
*
TXTPRTBL DS    0A                 TXT FORMAT TABLE
         DC    A(TXWORD1,PXDATA+0)
         DC    A(TXWORD2,PXDATA+4)
         DC    A(TXWORD3,PXDATA+8)
         DC    A(TXWORD4,PXDATA+12)
         DC    A(TXWORD5,PXDATA+16)
         DC    A(TXWORD6,PXDATA+20)
         DC    A(TXWORD7,PXDATA+24)
         DC    A(TXWORD8,PXDATA+28)
*
PRTONLY  DC    CL16'0123456789ABCDEF'  00-0F
         DC    CL16'                '  10-1F
         DC    CL16'                '  20-2F
         DC    CL16'                '  30-3F
         DC    CL16'           .<(+ '  40-4F
         DC    X'50'                   50 (AMPERSAND)
         DC    CL15'         !$*); '  51-5F
         DC    CL16'-/         ,%_>?'  60-6F
         DC    CL16'          :#@''="'  70-7F
         DC    CL16'                '  80-8F
         DC    CL16'                '  90-9F
         DC    CL16'                '  A0-AF
         DC    CL16'                '  B0-BF
         DC    CL16' ABCDEFGHI      '  C0-CF
         DC    CL16' JKLMNOPQR      '  D0-DF
         DC    CL16'  STUVWXYZ      '  E0-EF
         DC    CL16'0123456789      '  ZERO-FF
*
TSTVALID DC    256X'FF'           TRT SCAN TABLE
         ORG   TSTVALID+C'$'
         DC    X'00'
         ORG   TSTVALID+C'@'
         DC    X'00'
         ORG   TSTVALID+C'#'
         DC    X'00'
         ORG   TSTVALID+C'A'
         DC    9X'00'
         ORG   TSTVALID+C'J'
         DC    9X'00'
         ORG   TSTVALID+C'R'
         DC    8X'00'
         ORG   TSTVALID+C'0'
         DC    10X'00'
         ORG
*
TRCHAR   DC    CL16'0123456789ABCDEF' CHARACTER TRANSLATION TABLE
*
BINDERR  DS    0CL132             IEWBIND MACRO CALL ERROR MESSAGE
         DC    CL17'*** IEWBIND FUNC='
ERRFUNC  DS    CL8                IEWBIND FUNCTION
         DC    CL21', ERROR: RETURN CODE='
ERRETCD  DS    CL8                IEWBIND RETURN CODE
         DC    CL14', REASON CODE='
ERRSNCD  DS    CL8                IEWBIND REASON CODE
         DC    CL60' '
*
MORECNTL DC    X'01'              0=NO MORE CONTROL RECORDS
BADCNTL  DC    CL80'===> INVALID CONTROL RECORD FOLLOWS:'
BLANKS   DC    CL133' '           CONSTANT BLANKS
*
CTLRECD  DS    0CL80              CONTROL RECORD: MEMBER,CSECT NAMES
CRMEMBER DS    CL8' '               MEMBER NAME
         DS    CL1
CRCSECT  DS    CL8                  CSECT NAME
         DS    CL63
*
PRTLINE  DS    0CL133             PRINT LINE
PRTCC    DC    CL1'1'               CARRIAGE CONTROL BYTE
PRT      DC    CL132' '             PRINT DATA LINE
*
ESDPRT1  DS    0CL133             ESD PRINT LINE
         DC    CL7'0'               DOUBLESPACE CARRIAGE CONTROL
EPTYPE   DS    CL2                  ESD TYPE
         DC    CL1' '
EPTYPQL  DS    CL2                  ESD TYPE QUALIFIER
         DC    CL1' '
EPNAMSP  DS    CL1                  ESD NAME SPACE
         DC    CL1' '
EPSCOPE  DS    CL1                  ESD SCOPE
         DC    CL1' '
EPNAME   DS    CL8                  ESD NAME
         DC    CL1' '
EPATTRS  DS    CL2                  ESD ATTRIBUTES
         DC    CL1' '
EPRESNM  DS    CL8                  ESD RESIDENT SECTION NAME
         DC    CL1' '
EPLENGTH DS    CL8                  ESD LENGTH
         DC    CL1' '
EPALIGN  DS    CL2                  ESD ALIGNMENT
         DC    CL1' '
EPUSABIL DS    CL2                  ESD USABILITY
         DC    CL1' '
EPAMODE  DS    CL2                  ESD AMODE
         DC    CL1' '
EPRMODE  DS    CL2                  ESD RMODE
         DC    CL1' '
EPRECFMT DS    CL4                  ESD RECORD FORMAT FOR CLASS
         DC    CL1' '
EPLDFLGS DS    CL2                  ESD LOAD FLAGS
         DC    CL1' '
EPBNDFGS DS    CL2                  ESD BIND FLAGS
         DC    CL1' '
EPBNDCTL DS    CL2                  ESD BIND CONTROL
         DC    CL1' '
EPATTRCL DS    CL8                  ESD XATTR CLASS NAME
         DC    CL1' '
EPXTOFF  DS    CL8                  ESD XATTR OFFSET
         DC    CL1' '
EPSEGNO  DS    CL4                  ESD OVERLAY SEGMENT NUMBER
         DC    CL1' '
EPREGION DS    CL4                  ESD OVERLAY REGION NUMBER
         DC    CL1' '
EPSIGN   DS    CL8                  ESD SIGNATURE
         DC    CL1' '
EPAUTO   DS    CL2                  ESD AUTOCALL SPECIFICATION
         DC    CL1' '
EPSTATE DS     CL2                  ESD STATUS
         DC    CL1' '
EPTGTNM  DS    CL8                  ESD TARGET CSECT NAME
         DC    CL1' '
EPRESCL  DS    CL8                  ESD RESIDENT CLASS NAME
*
ESDPRT2  DS    0CL133             ESD PRINT LINE 2
         DC    CL1' '               SINGLE SPACE CARRIAGE CONTROL
         DC    CL15' '              SINGLE SPACE CARRIAGE CONTROL
EPELOFF  DS    CL8                  ESD ELEMENT OFFSET
         DC    CL1' '
EPCLOFF  DS    CL8                  ESD ELEMENT OFFSET
         DC    CL1' '
EPADA    DS    CL8                  ESD ASSOCIATED DATA
         DC    CL1' '
EPPRTY   DS    CL8                  ESD BINDING SEQUENCE
         DC    CL82' '
*
RLDPRT   DS    0CL133             RLD PRINT DATA LINE
         DC    CL1'0'                DOUBLESPACE CARRIAGE CONTROL
RLTYPE   DS    CL2                   RLD ADCON TYPE
         DC    CL1' '
RLSTATUS DS    CL2                   RLD ADCON RELOCATION STATUS
         DC    CL1' '
RLRESNM  DS    CL8                   RLD RESIDENT SECTION NAME
         DC    CL1' '
RLLENGTH DS    CL4                   RLD ADCON LENGTH
         DC    CL1' '
RLRESCL  DS    CL8                   RLD RESIDENT CLASS NAME
         DC    CL1' '
RLELOFF  DS    CL8                   RLD OFFSET TO ADCON W/IN CSECT
         DC    CL1' '
RLCLOFF  DS    CL8                   RLD OFFSET TO ADCON W/IN CLASS
         DC    CL1' '
RLBDRY   DS    CL2                   RLD ADCON BOUNDARY
         DC    CL1' '
RLBNDATR DS    CL2                   RLD ADCON BOUNDARY STATUS
         DC    CL1' '
RLATTRCL DS    CL8                   RLD EXT ATTR CLASS NAME
         DC    CL1' '
RLXTOFF  DS    CL8                   RLD EXT ATTR OFFSET IN ELEMENT
         DC    CL1' '
RLNAMSP  DS    CL2                   RLD NAME SPACE OF REFERENCE
         DC    CL1' '
RLTGTNM  DS    CL8                   RLD NAME OF SYMBOL POINTED TO
         DC    CL1' '
RLRSPRT  DS    CL8                   RLD NAME OF RESIDENT PART
         DC    CL41' '
*
TXTPRT   DS    0CL133             TEXT DATA PRINT LINE
         DC    CL1' '                SINGLE SPACED CARRIAGE CONTROL
TXDISPL  DS    CL6                   DISPLACEMENT FOR THE LINE
         DC    CL2' '
TXWORD1  DS    CL8                   TEXT WORD 1
         DC    CL1' '
TXWORD2  DS    CL8                   TEXT WORD 1
         DC    CL1' '
TXWORD3  DS    CL8                   TEXT WORD 1
         DC    CL1' '
TXWORD4  DS    CL8                   TEXT WORD 1
         DC    CL2' '
TXWORD5  DS    CL8                   TEXT WORD 1
         DC    CL1' '
TXWORD6  DS    CL8                   TEXT WORD 1
         DC    CL1' '
TXWORD7  DS    CL8                   TEXT WORD 1
         DC    CL1' '
TXWORD8  DS    CL8                   TEXT WORD 1
         DC    CL2' '
TXDLM1   DC    CL1'*'
TXCHARS  DS    CL32                  CHARACTERS
TXDLM2   DC    CL1'*'
         DC    CL17' '
*
***********************************************************************
* VARIABLE LENGTH STRING CONSTANTS USED AS PARAMETERS TO THE BINDER   *
* MACROS CONSIST OF A HALFWORD LENGTH FOLLOWED BY A TEST STRING OF THE*
* SPECIFIED LENGTH.                                                   *
***********************************************************************
B_ESD    DC    H'5',C'B_ESD'      ESD CLASS NAME
B_RLD    DC    H'5',C'B_RLD'      RLD CLASS NAME
B_TXT    DC    H'6',C'B_TEXT'     TEXT CLASS NAME
ALL      DC    H'3',C'ALL'        LIST OPTION VALUE
SYSLIB   DC    H'6',C'SYSLIB'     INCLUDE LIBRARY DDNAME=SYSLIB
LIST     DC    H'4',C'LIST'       LIST OPTION KEYWORD
MEMNAME  DS    0H                 MODULE (MEMBER) NAME
MEMLENG  DC    H'0'                 MEMBER NAME LENGTH
MEMBER   DC    CL8' '               MEMBER NAME TEXT
CSNAME   DS    0H                 CSECT NAME
CSLENG   DC    H'0'                 CSECT NAME LENGTH
CSECT    DC    CL8' '               CSECT NAME TEXT
TERM     DC    H'4',C'TERM'       TERM OPTION KEYWORD
Y        DC    H'1',C'Y'          TERM OPTION VALUE
***********************************************************************
*                       WORKING STORAGE                               *
***********************************************************************
SAVE2    DS    18F                ANOTHER FOR THE EXIT ROUTINE
SAVE13   DS    F                  REGISTER 13 SAVE
RETCODE  DC    F'0'               RETURN CODE FROM LMODREAD
NBRGETD  DS    F                  NUMBER OF ESD RECORDS RETURNED
NBRGETN  DS    F                  NUMBER OF SECTION NAMES
CRSRGETD DS    F                  CURSOR VALUE FOR GETD CALL
CRSRGETN DS    F                  CURSOR VALUE FOR GETN CALL
DCB@     DS    F                  DCB FOR OUTPUT FILE
DTOKEN   DS    XL8                DIALOG TOKEN
*           ***** RETURN CODES FROM IEWBIND MACRO CALLS *****
RTRNGETD DS    XL4                RETURN CODE FROM FUNC=GETD
RTRNSTR  DS    XL4                RETURN CODE FROM FUNC=STARTD
RTRNCRE  DS    XL4                RETURN CODE FROM FUNC=CREATEW
RTRNINCL DS    XL4                RETURN CODE FROM FUNC=INCLUDE
RTRNGETN DS    XL4                RETURN CODE FROM FUNC=GETN
RTRNDEL  DS    XL4                RETURN CODE FROM FUNC=DELETEW
RTRNENDD DS    XL4                RETURN CODE FROM FUNC=ENDD
*           ***** REASON CODES FROM IEWBIND MACRO CALLS *****
RSNCGETD DS    XL4                REASON CODE FROM FUNC=GETD
RSNCSTR  DS    XL4                REASON CODE FROM FUNC=GETD
RSNCCRE  DS    XL4                REASON CODE FROM FUNC=GETD
RSNCINCL DS    XL4                REASON CODE FROM FUNC=GETD
RSNCGETN DS    XL4                REASON CODE FROM FUNC=GETD
RSNCDEL  DS    XL4                REASON CODE FROM FUNC=GETD
RSNCENDD DS    XL4                REASON CODE FROM FUNC=GETD
*
TOTLGETN DS    F                  TOTAL NUMBER OF SECTIONS
WKTOKEN  DS    XL8                WORKMOD TOKEN
***********************************************************************
* DCB FOR OUTPUT FILE. THIS DCB IS USED BY THIS PROGRAM ONLY. IT IS   *
* NOT SHARED OR USED BY THE BINDER IN ANY WAY.                        *
***********************************************************************
OUTPUT1  DCB   DSORG=PS,MACRF=PM,DDNAME=OUTPUT1,                       X
               RECFM=FB,LRECL=80
PRINT1   DCB   DSORG=PS,MACRF=PM,DDNAME=PRINT1,                        X
               RECFM=FBA,LRECL=133
READER1  DCB   DSORG=PS,MACRF=GM,DDNAME=READER1,EODAD=GCENDCTL,        X
               RECFM=FB,LRECL=80
***********************************************************************
* NAMES AND ESD BUFFER MAPPINGS. NOTE THAT THE BUFFER VERSION MUST    *
* MATCH THE VERSION OF THE GETN AND THE GETD BINDER API'S. THE MAPBUF *
* FUNCTION OF THE IEWBUFF MACRO PROVIDES DSECT MAPS FOR BOTH THE ESD  *
* AND THE NAMES BUFFERS. REGISTERS 6 AND 7 ARE DEDICATED AS BASE REG- *
* ISTERS FOR THE ESD BUFFER HEADER AND ENTRIES, RESPECTIVELY. SIMIL-  *
* ARLY, REGISTERS 8 AND 9 ARE DEDICATED TO THE NAMES BUFFER.          *
* NOTE THAT YOU MUST CODE THE IEWBUFF MACRO WITHIN A CSECT. ALSO NOTE *
* THAT THE VERSION PARAMETER IN IEWBUFF MUST MATCH THE VALUE OF THE   *
* VERSION PARAMETER IN THE GETN AND GETD BINDER API'S.                *
***********************************************************************
         IEWBUFF FUNC=MAPBUF,TYPE=ESD,SIZE=50,VERSION=3,               C    C
               HEADREG=6,ENTRYREG=7
         IEWBUFF FUNC=MAPBUF,TYPE=RLD,SIZE=50,VERSION=3,               C    C
               HEADREG=6,ENTRYREG=7
         IEWBUFF FUNC=MAPBUF,TYPE=TEXT,BYTES=32768,VERSION=3,          C    C
               HEADREG=6,ENTRYREG=7
         IEWBUFF FUNC=MAPBUF,TYPE=NAME,SIZE=50,VERSION=3,              C    C
               HEADREG=6,ENTRYREG=7
         IEWBUFF FUNC=MAPBUF,TYPE=IDRL,SIZE=50,VERSION=3,              C    C
               HEADREG=6,ENTRYREG=7
         LTORG
***********************************************************************
* REGISTER EQUATES                                                    *
***********************************************************************
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
