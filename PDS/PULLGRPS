         PRINT NOGEN
         TITLE '*****PULLGRPS: SCAN COBOL SOURCE FOR DB CALLS *****'
PULLGRPS CSECT
PULLGRPS AMODE 24
PULLGRPS RMODE 24
         USING *,R15
         STM   R14,R12,12(R13)         SAVE CALLER'S REGS
         LR    R3,R15                  SET UP BASE FIRST BASE REG
         DROP  R15
         USING PULLGRPS,R3,R4
         LA    R4,4095(R3)             SET UP SECOND
         LA    R4,1(R4)                    BASE REGISTER
         LA    R15,MYSAVE              POINT TO MY REGISTER SAVE AREA
         ST    R15,8(R13)              SET LSA IN CALLER'S SAVE
         ST    R13,4(R15)              SET HSA IN MY SAVE AREA
         LR    R13,R15                 SET UP SAVE AREA POINTER
         B     START                   BRANCH AROUND CONSTANTS
         DC    CL8'PULLGRPS'           PROGRAM NAME IDENTIFIER
         DC    CL8'&SYSDATE'           ASSEMBLY DATE
         DC    CL8'&SYSTIME'           ASSEMBLY TIME
MYSAVE   DS    18F                     MY REGISTER SAVE AREA
***********************************************************************
* THIS PROGRAM SEARCHES COBOL SOURCE PROGRAMS FOR TEXT STRINGS THAT   *
* ARE USED TO IDENTIFY THE BEGINNING, OF A DESIRED STATEMENT, THE END *
* THE STATEMENT, AND A STRING WITHIN THE STATEMENT. WHEN A STATEMENT  *
* IS FOUND, ALL OF THE LINES COMPRISING THE STATEMENT ARE SAVED IN    *
* STORAGE. IF A MATCHING STRING IS FOUND WITHIN THE STATEMENT, IT IS  *
* SAVED, AS WELL. AT THE END OF THE STATEMENT, AN ANALYSIS PROGRAM IS *
* CALLED DYNAMICALLY. THE STATEMENT AND MATCHING STRING ARE PASSED TO *
* THE ANALYSIS PROGRAM. IN TYPICAL USE, THE STRGINIT FILE MIGHT       *
* THE STRING "EXEC SQL", THE STRGMTCH MIGHT CONTAIN THE STRING "AP10",*
* AND THE STRGTERM FILE WOULD CONTAIN A PERIOD, PLUS ALL COBOL VERBS. *
* DURING EXECUTION, WHEN A COBOL SOURCE PROGRAM LINE CONTAINED THE    *
* STRING "EXEC SQL", THE LINE-GROUP-IN-PROGRESS FLAG WOULD BE SET, AND*
* LINES WOULD BE STORED IN MEMORY UNTIL THE END OF THE STATEMENT WAS  *
* FOUND (OR 100 LINES WERE SAVED, WHICHEVER HAPPENS FIRST). EACH LINE *
* OF THE GROUP WOULD BE SEARCHED FOR THE MATCH STRING, "AP01". IF     *
* FOUND, THE "AP01" STRING WOULD BE SAVED, AND THE MATCH-FOUND FLAG   *
* WOULD BE SET. WHEN THE END OF THE STATEMENT IS ENCOUNTERED, THE     *
* ANALYSIS PROGRAM, WHOSE NAME IS SUPPLIED ON THE PARM FIELD OF THE   *
* EXEC JCL STATMENTT, IS CALLED DYNAMICALLY, PASSING IT THE AREA      *
* DESCRIBED BY THE PASSAREA LABEL. AN EXAMPLE OF A COBOL ANALYSIS     *
* PROGRAM LINKAGE SECTION FOLLOWS:                                    *
*         01  PASSAREA.                                               *
*             05  DSNAME                PIC X(44).                    *
*             05  MEMBER-NAME           PIC X(8).                     *
*             05  MATCHING-STRING       PIC X(72).                    *
*             05  STRING-FOUND-FLAG     PIC X.                        *
*                 88  MATCH-STRING-FOUND VALUE 'Y'.                   *
*             05  END-FOUND-FLAG        PIC X.                        *
*                 88  NORMAL-STATEMENT-END-FOUND VALUE 'Y'.           *
*             05  NUMBER-LINES-IN-GROUP PIC S9(3) COMP-3.             *
*             05  GROUP-LINE            PIC X(80)                     *
*                                       OCCURS 100 TIMES.             *
***********************************************************************
* GENERAL PROCESS FLOW IN PULLGRPS IS:                                *
*  1. GET THE ANALYSIS PROGRAM NAME FROM THE PARM FIELD OF THE EXEC   *
*     JCL STATEMENT AND USE IT TO LOAD THE ANALYSIS PROGRAM INTO      *
*     MEMORY. SAVE THE ENTRY POINT ADDRESS FOR LATER USE.             *
*  2. READS THE MEMBERS FILE TO BUILD A TABLE OF MEMBERS TO BE        *
*     INCLUDED OR EXCLUDED.                                           *
*  3. READS THE THREE STRINGS FILES (STRGINIT, STRGMTCH, AND STRGTERM)*
*     TO BUILD A TABLE OF STRINGS TO BE LOCATED.                      *
*  4. OPENS EACH FILE WHOSE DDNAME BEGINS WITH "INPUT". IF THE INPUT  *
*     DATASET IS A PDS, MEMBERS ARE AND PROCESSED PER THE MEMBER      *
*     TABLE CREATED IN STEP 1.                                        *
*  5. AS INPUT RECORDS ARE READ, THEY ARE CONVERTED TO ALL UPPER CASE.*
*     THE RECORD IS THEN SEARCHED TO SEE IF IT CONTAINS ANY OF THE    *
*     SPECIFIED STRINGS:                                              *
*     A. IN ALL CASES, WHETHER A STRING IF FOUND OR NOT:              *
*        1. IF A LINE GROUP IS IN PROGRESS:                           *
*           A. IF THIS IS THE 100TH LINE OF THE LINE GROUP:           *
*               1. LINE GROUP TERMINATION IS PERFORMED.               *
*           B. THE LINE IS STORED IN THE NEXT LINE OF THE LINE GROUP. *
*     B. IF A LINE GROUP IS IN PROGRESS:                              *
*        1. IF THE STRING FOUND IS AN INIT STRING:                    *
*           A. LINE GROUP TERMINATION IS PERFORMED.                   *
*           B. LINE GROUP INITIALIZATION IS PERFORMED.                *
*        2. IF THE STRING FOUND IS A MTCH STRING:                     *
*           A. IF A MTCH STRING HAS NOT YET BEEN FOUND:               *
*              1. THE MTCH FOUND FLAG IS SET.                         *
*              2. THE MATCHING STRING IS STORED FOR ANALYSIS.         *
*        3. IF THE STRING FOUND IS A TERM STRING:                     *
*           A. THE NORMAL END FOUND FLAG IS SET.                      *
*           B. LINE GROUP TERMINATION IS PERFORMED.                   *
*     C. IF NO LINE GROUP IS IN PROGRESS:                             *
*        1. IF THE STRING FOUND IS AN INIT STRING:                    *
*           A. LINE GROUP INITIALIZATION IS PERFORMED.                *
*  5. LINE GROUP TERMINATION IS A ROUTINE THAT CALLS THE EXTERNAL     *
*     ANALYSIS PROGRAM, PASSING IT THE LINE GROUP THAT HAS BEEN       *
*     EXTRACTED, THE MATCH FLAG, THE STRING FOUND (IF ANY). ON RETURN *
*     FROM THE ANALYSIS PROGRAM, THE LINE GROUP DATA IS CLEANED UP IN *
*     PREPARATION FOR THE NEXT LINE GROUP.                            *
***********************************************************************
*         INPUT DATA FILE DESCRIPTIONS                                *
***********************************************************************
* THE MEMBERS INPUT FILE MUST RECFM=FB,LRECL=80. THIS FILE CONTAINS A *
* LIST OF THE MEMBER NAMES TO BE INCLUDED OR EXCLUDED, ONE NAME PER   *
* RECORD. COLUMN 1 MUST BE 'I' TO INCLUDE OR 'E' TO EXCLUDE THE       *
* MEMBER. COLUMN 2 IS BLANK, AND THE MEMBER NAME IS IN COL 3-10. UP TO*
* 500 MEMBER NAME RECORDS ARE PERMITTED. WILDCARD CHARACTERS ARE      *
* PERMITTED, WHERE THE * MEANS ALL CHARACTERS FROM THAT POINT ON CAN  *
* HAVE ANY VALUE AND ARE NOT COMPARED. THE ? IS USED FOR A PARTICULAR *
* POSITION THAT MAY CONTAIN ANY CHARACTER, AND IS NOT COMPARED. ALL   *
* POSITIONS NOT CONTAINING * OR ? MUST BE EQUAL. MEMBER SELECTION     *
* RECORDS ARE PROCESSED IN THE ORDER ENTERED. INCLUDE RECORDS FORCE   *
* INCLUSION, WHILE EXCLUDE RECORDS FORCE EXCLUSION. ANY MEMBER PASSING*
* THROUGH THE MEMBER TABLE IS INCLUDED.                               *
* EXAMPLES:                                                           *
* I BP*    INCLUDES ALL MEMBERS BEGINNING WITH BP                     *
* E ?P*    EXCLUDES ALL MEMBERS HAVING P IN COL 2 EXCEPT THE BP       *
*          MEMBERS WHICH WERE INCLUDED BEFORE THIS EXCLUDE.           *
* I *OP    MATCHES ALL MEMBERS. DATA FOLLOWING THE * IS IGNORED.      *
* I XMW5467A      MATCHES ONLY XMW5467A (NO WILD CARDS)               *
* E XPP50?P       MATCHES XPP50RP, XPP507P, XPP50@P                   *
***********************************************************************
* THE STRINGS FILES MUST ALSO BE RECFM=FB,LRECL=80. THESE THREE FILES *
* CONTAIN THE STRINGS TO BE LOCATED IN THE INPUT FILES. UP TO 500     *
* STRINGS MAY BE ENTERED IN EACH FILE. THE STRING IS ASSUMED TO BEGIN *
* IN COLUMN 1 (WHICH MAY BE BLANK TO INCLUDE LEADING SPACES), AND ENDS*
* WITH EITHER THE LAST NON-BLANK COLUMN, OR ONE COLUMN LEFT OF THE    *
* LAST NON-BLANK COLUMN IF IT CONTAINS A "<". IF THE LAST CHARACTER   *
* OF THE STRING TO BE FOUND IS AN "<", IT MUST BE FOLLOWED BY ANOTHER *
* "<". THIS PERMITS TRAILING BLANKS TO BE INCLUDED IN THE STRING.     *
*                                                                     *
* AUTHOR R THORNTON APR 2001 BASED ON THE SCANTEXT PROGRAM            *
***********************************************************************
*
***********************************************************************
* INITIALIZATION: PROCESS THE PARM FIELD TO GET THE ANALYSIS PROGRAM  *
* NAME. LOAD THE PROGRAM AND SAVE ITS ENTRY POINT ADDRESS.            *
***********************************************************************
START    L     R2,0(R1)                GET PARM FIELD ADDR
         CLC   0(2,R2),X'0000'         ANY PARM DATA ENTERED?
         BE    NOPARM                  NO, ERROR
         CLC   0(2,R2),X'0008'         VALID PARM LENGTH?
         BH    BADPARM                 NO, ERROR
         LH    R12,0(R2)               PICK UP PARM LENGTH
         BCTR  R12,0                   SUBTRACT 1 FOR LENGTH CODE
         EX    R12,MVCPARM             MOVE ANALYSIS PROGRAM NAME
         LOAD  EPLOC=ANALPGMN          LOAD THE ANALYSIS PROGRAM
         LTR   R15,R15                 SUCCESSFUL LOAD?
         BNZ   BADLOAD                 NO, ERROR
         ST    R0,ANALPGMA             SAVE ANALYSIS PROGRAM E.P. ADDR
         B     GETCVT                  CONTINUE
NOPARM   WTO   'PULLGRPS: NO ANALYSIS PROGRAM NAME ON THE EXEC PARM',  X
               ROUTCDE=11
         ABEND 111,DUMP                TERMINATE IN ERROR
BADPARM  WTO   'PULLGRPS: EXEC PARM MUST HAVE A 1-8 BYTE PROGRAM NAME',X
               ROUTCDE=11
         ABEND 222,DUMP                TERMINATE IN ERROR
BADLOAD  WTO   'PULLGRPS: UNABLE TO LOAD ANALYSIS PROGRAM NAMED',      X
               ROUTCDE=11
         ABEND 333,DUMP
MVCPARM  MVC   ANALPGMN(1),2(R2)       MOVE ANALYSIS PROGRAM NAME
GETCVT   L     R1,16                   GET CVT ADDRESS
         L     R1,0(R1)                GET CVTTCBP
         L     R1,0(R1)                GET TCB ADDRESS
         L     R1,12(R1)               GET TIOT ADDRESS
         LA    R1,24(R1)               GET ADDRESS OF 1ST DD ENTRY
         ST    R1,TIOTDD               SAVE TIOT DD ENTRY ADDRESS
***********************************************************************
* INITIALIZATION: OPEN AND READ THE MEMBERS FILE STORING MEMBER NAMES *
* IN THE MEMBERTB TABLE. AT END OF FILE, CLOSE THE MEMBERS FILE.      *
***********************************************************************
         STORAGE OBTAIN,LENGTH=4500    GET STORAGE FOR MEMBERTB
         ST    R1,MBRTBL               SAVE MEMBERTB ADDRESS
         ST    R1,MBRCURR              SAVE CURRENT MEMBERTB ADDRESS
         A     R1,=F'4500'             COMPUTE TABLE END ADDRESS
         ST    R1,MBREND               SAVE MEMBERTB END ADDRESS
         OPEN  (MEMBERS,,SYSPRINT,OUTPUT) OPEN FILES
         L     R12,MBRTBL              POINT TO MEMBER TABLE
READMTBL GET   MEMBERS,STRCARD         READ MEMBER RECORD
         CLI   STRCARD,C'*'            COMMENT RECORD?
         BE    READMTBL                YES, GO READ NEXT
CVTUCASE TR    STRCARD,UPRCASE         CONVERT CASE AS SPECIFIED
         CLI   STRCARD,C'I'            INCLUDE RECORD?
         BE    PUTMBR                  YES
         CLI   STRCARD,C'E'            EXCLUDE RECORD?
         BE    PUTMBR                  YES
         MVI   MEMTYPE,X'FF'           NEITHER, SHOW ERROR
         MVC   PRT(15),STRCARD         MEMBERS FILE RECORD TO PRINT
         MVC   PRT+15(23),=CL23'INVALID INCLUDE/EXCLUDE'
         PUT   PRT,PRTLINE             WRITE ERROR MESSAGE
         MVC   PRTLINE,BLANKS          CLEAR PRINT LINE
PUTMBR   C     R12,MBREND              PAST END OF TABLE?
         BH    EXCEEDS                 YES, ERROR
         MVC   0(1,R12),STRCARD        MOVE INCLUDE/EXCLUDE TYPE
         MVC   1(8,R12),STRCARD+2      MOVE MEMBER TO TABLE
         LA    R12,9(R12)              ADVANCE TO NEXT ENTRY
         B     READMTBL                CONTINUE
EXCEEDS  WTO   'TOO MANY MEMBER RECORDS, 500 MAX',ROUTCDE=11
         ABEND 112,DUMP                TERMINATE IN ERROR
MEMERRS  WTO   'INVALID MEMBER RECORDS, CHECK LISTING',ROUTCDE=11
         ABEND 113,DUMP                TERMINATE IN ERROR
ENDMBTBL CLI   MEMTYPE,X'FF'           ERRORS FOUND?
         BE    MEMERRS                 YES, GO TERMINATE IN ERROR
         MVI   0(R12),X'FF'            SET TABLE END INDICATOR
         CLOSE MEMBERS                 CLOSE THE MEMBERS FILE
***********************************************************************
* INITIALIZATION: OPEN THE STRINGS FILE TO READ STRGINIT AND PERFORM  *
* THE READSTRG ROUTINE TO LOAD THE STRINGS INTO THE STRINGTB TABLE.   *
* AT END, SET THE STRINGS DCB TO POINT TO THE STRGMTCH DD , OPEN THE  *
* FILE, AND PROCESS READSTRG TO LOAD THE STRINGS INTO THE STRINGTB    *
* TABLE. FINALLY, SET THE STRINGS DCB TO THE STRGTERM DD AND PERFORM  *
* READSTRG TO LOAD IT INTO THE TABLE, THEN PROCEED TO SORTSTRG.       *
***********************************************************************
         STORAGE OBTAIN,LENGTH=111000  GET STRINGTB STORAGE
         ST    R1,STRTBL               SAVE TABLE ADDRESS
         ST    R1,STRCURR              SAVE CURRENT TABLE ADDRESS
         A     R1,=F'111000'           COMPUTE TABLE END ADDRESS
         ST    R1,STREND               SAVE STRINGTB END ADDRESS
         OPEN  STRINGS                 OPEN TO THE STRGINIT FILE
         B     READSTRG                GO LOAD THE STRINGS
ENDINIT  CLOSE STRINGS                 CLOSE THE STRGINIT FILE
         FREEPOOL STRINGS              FREE THE BUFFERS
         MVC   STRINGS+40(8),=CL8'STRGMTCH' CHANGE DDNAME IN STRINGS
         MVC   STRINGS+33(3),=AL3(ENDMTCH) CHANGE THE EOF ADDRESS
         OPEN  STRINGS                 OPEN THE STRGMTCH FILE
         MVI   STRGTYPE,C'M'           SET THE TYPE TO MTCH
         B     READSTRG                GO LOAD THE STRINGS
ENDMTCH  CLOSE STRINGS                 CLOSE THE STRGMTCH FILE
         FREEPOOL STRINGS              FREE THE BUFFERS
         MVC   STRINGS+40(8),=CL8'STRGTERM' CHANGE DDNAME IN STRINGS
         MVC   STRINGS+33(3),=AL3(ENDTERM) CHANGE THE EOF ADDRESS
         OPEN  STRINGS                 OPEN THE STRGTERM FILE
         MVI   STRGTYPE,C'T'           SET THE TYPE TO MTCH
         B     READSTRG                GO LOAD THE STRINGS
ENDTERM  CLOSE STRINGS                 CLOSE THE STRGTERM FILE
         FREEPOOL STRINGS              FREE THE BUFFERS
         B     SORTSTRG                GO SORT THE STRINGS
***********************************************************************
* INITIALIZATION: PERFORMED BY CODE ABOVE FOR EACH OF THE THREE       *
* STRINGS FILES. THE STRING FILE IS READ TO EXHAUSTION, AND AT END    *
* OF FILE THE ROUTINE ABOVE IS ENTERED AT THE APPROPRIATE END OF FILE *
* POINT. AS EACH STRING RECORD IS READ, THE STRING LENGTH IS COMPUTED,*
* AND THE STRING IS STORED LEFT JUSTIFIED IN THE LAST 72 BYTES OF THE *
* TABLE ENTRY. THE FIRST BYTE OF EACH ENTRY IS USED TO CONTAIN THE    *
* LENGTH CODE (LENGTH-1) OF THE STRING, AND THE SECOND BYTE IS THE    *
* STRING TYPE (I=INIT, M=MTCH, T=TERM) FROM THE STRGTYPE FIELD.       *
***********************************************************************
READSTRG GET   STRINGS,STRCARD         READ STRING RECORD
         TR    STRCARD,UPRCASE         CONVERT TO ALL UPPER CASE
         CLI   STRCARD,C'*'            COMMENT RECORD?
         BE    READSTRG                YES, GO READ AGAIN
         L     R1,STRCURR              POINT TO CURRENT ENTRY
         C     R1,STREND               PAST END OF TABLE?
         BH    EXCEED2                 YES, ERROR
         LA    R15,71                  GET MAX POSSIBLE LENGTH CODE
         LA    R14,STRCARD+71          POINT TO LAST POSSIBLE TERM
CRDLNBK  CLI   0(R14),C' '             FOUND LAST NON-BLANK COLUMN?
         BNE   LASNONBK                YES
         BCTR  R15,0                   NO, DECREMENT STRING LENGTH CODE
         BCT   R14,CRDLNBK             DECREMENT POINTER AND LOOP
LASNONBK CLI   0(R14),C'<'             GOT THE TERMINATOR SIGN?
         BNE   SAVELENG                NO
         BCTR  R15,0                   YES, DON'T INCLUDE IN LENGTH
SAVELENG STC   R15,0(R1)               YES, SAVE STRING LENGTH
         MVC   2(72,R1),BLANKS         PRE-CLEAR ENTRY
         EX    R15,TBLMOVE             MOVE STRING TO TABLE
         MVC   1(1,R1),STRGTYPE        MOVE STRING TYPE TO TABLE ENTRY
         LA    R1,74(R1)               ADVANCE TO NEXT ENTRY
         ST    R1,STRCURR              SAVE CURRENT ENTRY POINTER
         B     READSTRG                CONTINUE
TBLMOVE  MVC   2(1,R1),STRCARD         EXECUTED MOVE
EXCEED2  WTO   'TOO MANY STRING RECORDS, 500 MAX',ROUTCDE=11
         ABEND 114,DUMP                TERMINATE IN ERROR
***********************************************************************
* INITIALIZATION: SORT THE STRINGS IN STRINGTB IN ASCENDING ORDER.    *
***********************************************************************
SORTSTRG L     R1,STRCURR              GET NEXT TABLE ADDRESS
         MVI   0(R1),X'00'             SET END ENTRY LENGTH = 1
         MVI   1(R1),X'FF'             SET END ENTRY DATA = FF
         ST    R1,STREND               SET ACTUAL TABLE END
         L     R1,STRTBL               POINT TO TABLE START
NEXPASS  LR    R2,R1                   POINT TO 1ST PASS ENTRY
NEXNTRY  LA    R2,74(R2)               POINT TO NEXT ENTRY
         C     R2,STREND               PAST END OF TABLE?
         BH    ENDPASS                 YES
         CLC   2(72,R2),2(R1)          2ND ENTRY IS LOW?
         BL    SRTSWCH                 YES, GO SWITCH
         B     NEXNTRY                 NO, CONTINUE PASS
SRTSWCH  MVC   STRCARD(74),0(R1)       SAVE 1ST ENTRY
         MVC   0(74,R1),0(R2)          MOVE 2ND TO 1ST
         MVC   0(74,R2),STRCARD        MOVE 1ST TO SECOND
         B     NEXNTRY                 CONTINUE PASS
ENDPASS  LA    R1,74(R1)               POINT TO NEXT TABLE ENTRY
         C     R1,STREND               PAST END OF TABLE?
         BL    NEXPASS                 NO
***********************************************************************
* INITIALIZATION: CHECK THE FIRST BYTE OF THE FIRST STRING IN THE     *
* TABLE. IF IT IS LOWER THAN THE LETTER "A", PUT THE ADDRESS OF THE   *
* FIRST STRING ENTRY IN THE LOWPTR FIELD FOR USE IN LATER SCANNING.   *
* NEXT, MOVE THE VALUE X'01' TO THE LOCATION IN THE TRTSCH TRT TABLE  *
* CORRESPONDING TO THIS BYTE. THIS WILL CAUSE THE SCANNING TRT TO     *
* STOP WHEN THIS BYTE IS FOUND IN AN INPUT SOURCE RECORD. CONTINUE TO *
* SEARCH THROUGH THE STRING TABLE SO LONG AS THE STRINGS BEGIN WITH   *
* VALUES LESS THAN THE LETTER "A", SETTING THE CORRESPONDING TRT TABLE*
* LOCATION TO X'01' FOR EACH ONE FOUND.                               *
***********************************************************************
ENDSORT  L     R1,STRTBL               POINT TO TABLE START
         CLI   2(R1),C'A'              1ST STRING BEGINS < A?
         BNL   FINDALFA                NO
         STCM  R1,7,LOWPTR+1           YES, SET BEGIN SRCH ADDRESS
FINDALFA CLI   2(R1),C'A'              FOUND FIRST ALPHA?
         BNL   ALFACHEK                PERHAPS
         SR    R14,R14                 CLEAR FOR INSERT
         IC    R14,2(R1)               PICK UP 1ST BYTE OF STRING
         LA    R14,TRTSCH(R14)         POINT TO TRT TABLE BYTE
         MVI   0(R14),X'01'            SET STOP FOR THIS BYTE
         LA    R1,74(R1)               STEP TO NEXT ENTRY
         C     R1,STREND               PAST END OF TABLE?
         BH    NEWINFIL                YES
         B     FINDALFA                ELSE CONTINUE SEARCH
***********************************************************************
* INITIALIZATION: ON ENTRY, R1 POINTS TO A STRING TABLE ENTRY. THIS   *
* ROUTINE BEGINS AT THAT ENTRY AND SEARCHES THROUGH THE STRING TABLE  *
* UNTIL THE TABLE IS EXHAUSTED, OR A STRING IS FOUND HAVING A FIRST   *
* BYTE GREATER THAN THE LETTER "Z". FOR EACH NEW ALPHABETIC           *
* CHARACTER FOUND STARTING A STRING, THE ADDRESS OF THE FIRST STRING  *
* WITH THIS STARTING LETTER IS MOVED TO THE ADDRESS TABLE ENTRY (APTR *
* THROUGH ZPTR). IN ADDITION, A VALUE BETWEEN 01 AND 1B CORRESPONDING *
* TO A-Z IS MOVED TO THE SCANNING TABLE, TRTSCH, SO THAT THE BYTE WILL*
* STOP THE SCANNING TRT IF FOUND WITHIN AN INPUT RECORD.              *
***********************************************************************
ALFACHEK CLI   2(R1),C'Z'              STRING BEGINS WITH ALPHABETIC?
         BH    GOTHIONE                NO
         LA    R15,APTR                POINT TO LOAD ADDR TABLE
NEWALFA  CLC   2(1,R1),0(R15)          FOUND ENTRY FOR THIS LETTER?
         BE    SAVALFAD                YES
NEWSTEP  LA    R15,4(R15)              NO, ADVANCE AN ENTRY
         C     R15,LDADEND             PAST END OF TABLE?
         BH    NEWINFIL                YES
         B     NEWALFA                 NO, CONTINUE SEARCH
SAVALFAD STCM  R1,7,1(R15)             SET ADDRESS IN ENTRY
         SR    R2,R2                   CLEAR FOR INSERT
         IC    R2,2(R1)                GET 1ST BYTE OF STRING
         LA    R14,TRTSCH(R2)          POINT TO TRT TABLE BYTE
         CLI   2(R1),C'R'              ALPHA S-Z?
         BNL   GOTSZ                   YES
         CLI   2(R1),C'J'              ALPHA J-R?
         BNL   GOTJR                   YES
         LA    R2,65(R2)               CONVERT A-I TO 02-0A
         B     SETTABL                 GO SET IN TABLE
GOTJR    LA    R2,58(R2)               CONVERT J-R TO 0B-13
         B     SETTABL                 GO SET IN TABLE
GOTSZ    LA    R2,50(R2)               CONVERT S-Z TO 14-1B
SETTABL  STC   R2,0(R14)               SET BYTE IN TRT TABLE
ALFASTEP LA    R1,74(R1)               STEP TO NEXT STRING IN TABLE
         C     R1,STREND               PAST END OF TABLE?
         BH    NEWINFIL                YES
         CLC   2(1,R1),0(R15)          1ST STRING BYTE SAME AS LAST?
         BE    ALFASTEP                YES, CONTINUE
         CLI   2(R1),C'Z'              STILL ALPHABETIC?
         BH    GOTHIONE                NO, GO FINISH
         B     NEWSTEP                 CONTINUE
***********************************************************************
* INITIALIZATION: ON ENTRY, R1 POINTS TO A STRING TABLE ENTRY. THE    *
* FIRST BYTE OF THE STRING IS GREATER THAN THE LETTER "Z". THE ADDRESS*
* OF THIS ENTRY IS MOVED TO THE HIPTR FIELD, AND THE VALUE X'1C' IS   *
* SET IN THE TRTSCH TRT TABLE AT THE LOCATION CORRESPONDING TO THE    *
* VALUE OF THE STRING'S FIRST BYTE. THE REST OF THE STRING TABLE IS   *
* SEARCHED, AND X'1C' IS MOVED TO THE TRTSCH TABLE FOR EACH DIFFERENT *
* STRING STARTING VALUE.                                              *
***********************************************************************
GOTHIONE STCM  R1,7,HIPTR+1            SET LOAD ADDRESS POINTER
HICLEAR  SR    R2,R2                   CLEAR FOR INSERT
         IC    R2,2(R1)                PICK UP STARTING BYTE
         LA    R14,TRTSCH(R2)          POINT TO BYTE
         MVI   0(R14),X'1C'            SET TRT STOP
         LA    R1,74(R1)               STEP TO NEXT STRING
         C     R1,STREND               PAST END OF TABLE?
         BNH   HICLEAR                 NO, CONTINUE
***********************************************************************
* INITIALIZATION:  CHECK THE LENGTH OF INPUT FILE RECORDS TO INSURE   *
* THE FILE HAS FIXED LENGTH 80-BYTE RECORDS, AND IS EITHER PHYSICALLY *
* SEQUENTIAL, OR IS A PDS. IF PHYSICALLY SEQUENTIAL, OR IF A SPECIFIC *
* PDS MEMBER IS CODED IN THE JCL, SET THE SWITCH TO SHOW THE INPUT    *
* FILE IS A SIMPLE SEQUENTIAL FILE. IF AN ENTIRE PDS IS INPUT, CALL   *
* THE READDIR AND READMEM SUBROUTINES TO OPEN THE FILE.               *
***********************************************************************
NEWINFIL L     R1,TIOTDD               GET TIOT DD ENTRY ADDRESS
         SR    R2,R2                   CLEAR WORK REG
CKLSTDD  CLI   0(R1),0                 LAST TIOT DD ENTRY
         BE    EOJ                     YES
         CLC   4(5,R1),=C'INPUT'       DDNAME BEGINS WITH INPUT?
         BE    USEDD                   YES
DDSTEP   IC    R2,0(R1)                GET DD ENTRY LENGTH
         AR    R1,R2                   STEP TO NEXT DD ENTRY
         B     CKLSTDD                 GO CK NEXT DD
USEDD    MVC   INPUT+40(8),4(R1)       MOVE DNAME IN TIOT TO DCB
         IC    R2,0(R1)                GET DD ENTRY LENGTH
         AR    R1,R2                   STEP TO NEXT DD ENTRY
         ST    R1,TIOTDD               SAVE IT'S ADDRESS
         MVC   OPEN+6(3),INPUT+45      DDNAME TO OPEN PARM FOR READMEM
         MVC   CLOSE+6(3),INPUT+45     DDNAME TO CLOSE PARM FOR READMEM
         OPEN  INPUT                   OPEN THE FILE FOR INPUT
         RDJFCB INPUT                  READ JFCB FOR INPUT FILE
         MVC   DSNAME,JFCB             SAVE DSNAME
         MVC   MEMBER,BLANKS           CLEAR MEMBER NAME
         MVI   LGPROG,C'N'             RESET LINE GROUP SWITCH
         MVI   FOUNDSW,C'N'            RESET STRING FOUND SWITCH
         MVI   ENDFDSW,C'N'            RESET END FOUND SWITCH
         MVC   STRINGFD,BLANKS         CLEAR THE STRING FOUND FIELD
         ZAP   NBRLINES,=P'0'          CLEAR GROUP LINE COUNTER
         MVC   CURRLINE,=A(LINEGRP)    SET STARTING LINE GROUP POINTER
         CLC   JFCLRECL,H80            80-BYTE LOGICAL RECORDS?
         BNE   BADINPUT                NO, ERROR
         TM    JFCRECFM,X'C0'          POSSIBLE FIXED LENGTH RECORDS?
         BNM   BADINPUT                NO, ERROR
         TM    JFCRECFM,X'80'          FIXED LENGTH RECORDS?
         BZ    BADINPUT                NO, ERROR
         CLI   JFCDSORG,X'40'          DSORG=PS?
         BE    SIMPLSEQ                YES, SIMPLE SEQUENTIAL
         CLI   JFCDSORG,X'02'          DSORG=PO?
         BNE   BADINPUT                NO, ERROR
         CLI   JFCELNM,C' '            MEMBER NAME SPECIFIED?
         BH    SIMPLSEQ                YES, SIMPLE SEQUENTIAL
         CALL  READDIR,OPEN            OPEN DIRECTORY FILE
         CALL  READMEM,OPEN            OPEN MEMBER FILE
         B     INITFINI                GO FINISH INITIALIZATION
SIMPLSEQ MVI   SEQFILE,1               INDICATE SIMPLE SEQUENTIAL
         MVC   MEMNAME,JFCELNM         SET MEMBER NAME, IF ANY
         MVC   MEMBER,JFCELNM          SAVE MEMBER NAME
         B     READMEM                 GO PROCESS SEQUENTIAL FILE
BADINPUT WTO   'PULLGRPS: INVALID INPUT FILE. FILE MUST BE',ROUTCDE=11
         WTO   '         DSORG=PS OR DSORG=PO, LRECL=80,',ROUTCDE=11
         WTO   '         AND RECFM=F OR RECFM=FB',ROUTCDE=11
         ABEND 777,DUMP                TERMINATE IN ERROR
INITFINI LA    R12,MEMREC+71           POINT TO LAST BYTE OF RECORD
***********************************************************************
* MAINLINE PROCESSING: IF A PDS IS INPUT, LOCATE THE NEXT MEMBER,     *
* CHECK INCLUDE/EXCLUDE TABLE TO SEE IF IT IS DESIRED, AND IF SO,     *
* POSITION TO IT, AND READ RECORDS TO END OF MEMBER, REPEATING UNTIL  *
* THERE ARE NO MORE MEMBERS. IF A SIMPLE SEQUENTIAL DATASET IS INPUT, *
* READ RECORDS TO END OF FILE. FOR EACH RECORD READ, SCAN FOR STRINGS.*
* IF A STRING IS FOUND IN AN INPUT RECORD:                            *
*     A. IN ALL CASES, WHETHER A STRING IF FOUND OR NOT:              *
*        1. IF A LINE GROUP IS IN PROGRESS:                           *
*           A. IF THIS IS THE 100TH LINE OF THE LINE GROUP:           *
*               1. LINE GROUP TERMINATION IS PERFORMED.               *
*           B. THE LINE IS STORED IN THE NEXT LINE OF THE LINE GROUP. *
*     B. IF A LINE GROUP IS IN PROGRESS:                              *
*        1. IF THE STRING FOUND IS AN INIT STRING:                    *
*           A. LINE GROUP TERMINATION IS PERFORMED.                   *
*           B. LINE GROUP INITIALIZATION IS PERFORMED.                *
*        2. IF THE STRING FOUND IS A MTCH STRING:                     *
*           A. IF A MTCH STRING HAS NOT YET BEEN FOUND:               *
*              1. THE MTCH FOUND FLAG IS SET.                         *
*              2. THE MATCHING STRING IS STORED FOR ANALYSIS.         *
*        3. IF THE STRING FOUND IS A TERM STRING:                     *
*           A. THE NORMAL END FOUND FLAG IS SET.                      *
*           B. LINE GROUP TERMINATION IS PERFORMED.                   *
*     C. IF NO LINE GROUP IS IN PROGRESS:                             *
*        1. IF THE STRING FOUND IS AN INIT STRING:                    *
*           A. LINE GROUP INITIALIZATION IS PERFORMED.                *
***********************************************************************
NEWMEM   CALL  READDIR,(READ,DIRECTRY) READ NEXT DIRECTORY ENTRY
         CLI   MEMNAME,EOFHI           END OF FILE
         BH    ENDFILE                 YES, END OF PDS
         CLI   MEMNAME,EOFLO           END OF FILE
         BL    ENDFILE                 YES, END OF PDS
         L     R12,MBRTBL              POINT TO MEMBER TABLE
CKMBND   ST    R12,MBRCURR             SAVE CURRENT POINTER
         CLI   0(R12),X'FF'            END OF TABLE?
         BNE   BKTSTEQ                 NO
         B     DOFIND                  NOT EXCLUDED, INCLUDE IT
BKTSTEQ  LA    R1,8                    NBR BYTES TO COMPARE
         LA    R2,MEMNAME              POINT TO MEMBER NAME
         MVC   MEMTYPE,0(R12)          SAVE INCLUDE/EXCLUDE TYPE
         LA    R12,1(R12)              POINT TO MEMBER NAME
MEMCMPR  CLI   0(R12),C'*'             REST IS WILD?
         BE    MEMMTCH                 YES, GOT A MATCH
         CLI   0(R12),C'?'             THIS A WILD POSITION?
         BE    MEMSTEP                 YES, DON'T TEST
         CLC   0(1,R12),0(R2)          NOT WILD, BYTES SAME?
         BE    MEMSTEP                 YES, DON'T TEST
         L     R12,MBRCURR             POINT TO CURRENT MEMBER
         LA    R12,9(R12)              POINT TO NEXT TABLE ENTRY
         B     CKMBND                  MISMATCH, CHECK NEXT ENTRY
MEMSTEP  LA    R12,1(R12)              ADVANCE IN MEMBER TABLE ENTRY
         LA    R2,1(R2)                ADVANCE IN PDS MEMBER NAME
         BCT   R1,MEMCMPR              LOOP THROUGH NAME
MEMMTCH  L     R12,MBRCURR             POINT TO TABLE ENTRY MATCHED
         CLI   MEMTYPE,C'I'            MATCH, THIS AN INCLUDE?
         BNE   NEWMEM                  GO TO NEXT MEMBER
DOFIND   MVC   FINDNAM,MEMNAME         NAME TO FIND LIST
         CALL  READMEM,FIND            LOCATE MEMBER
         CLI   FINDNAM,0               MEMBER FOUND
         BE    NEWMEM                  NO, TRY NEXT MEMBER
READMEM  CLI   SEQFILE,0               INPUT IS A PDS?
         BE    CALLREAD                YES
         GET   INPUT,MEMREC            NO, READ NEXT RECORD
         B     CHEKRECD                GO PROCESS IT
CALLREAD CALL  READMEM,(READ,MEMREC)   READ NEXT RECORD IN MEMBER
         CLI   MEMREC,EOF              IS IT EOF
         BNE   CHEKRECD                NO, GO PROCESS IT
         BAL   R14,ANALYSIS            GO PROCESS ANY LINE GROUP
         B     NEWMEM                  THEN GO TO NEXT MEMBER
CHEKRECD MVC   SAVEREC,MEMREC          SAVE ORIGINAL
         CLI   LGPROG,C'Y'             LINE GROUP IN PROGRESS?
         BNE   TNSLATE                 NO
         CP    NBRLINES,=P'99'         LINE GROUP AREA IS FULL?
         BL    CRPTCURR                NO
         BAL   R14,ANALYSIS            YES, GO FORCE IT OUT
CRPTCURR L     R1,CURRLINE             YES, POINT TO CURRENT LINE
         MVC   0(80,R1),MEMREC         MOVE RECORD TO LINE GROUP AREA
         LA    R1,80(R1)               STEP TO NEXT LINE LOCATION
         ST    R1,CURRLINE             SAVE NEW POINTER
         AP    NBRLINES,=P'1'          ADD 1 TO COUNTER
TNSLATE  TR    MEMREC,UPRCASE          CONVERT LOWER TO UPPER CASE
         LA    R11,MEMREC-1            GET RECORD ADDRESS - 1
TRTSCAN  SR    R2,R2                   CLEAR FOR TRT INSERT
         TRT   1(80,R11),TRTSCH        SCAN FOR POSSIBLE STRING
         BZ    READMEM                 NONE FOUND, GO READ AGAIN
         C     R1,MRECND               FOUND WITHIN RECORD?
         BH    READMEM                 NO, EXIT
         LA    R1,0(R1)                CLEAR HI ORDER BYTE
         LR    R11,R1                  COPY ADDRESS FOUND
         LR    R15,R12                 COPY END ADDRESS
         SR    R15,R11                 LENGTH REMAINING IN RECORD
         SLL   R2,3                    MULTIPLY TRT CODE FOR BRANCH
         B     BRTBL-8(R2)             GO GET STRING TABLE POINTER
BRTBL    L     R2,LOWPTR               POINT TO 1ST STRING IN TABLE
         B     STRSRCH                 GO SEARCH TABLE
ASRCH    L     R2,APTR                 POINT TO 1ST STRING STARTING "A"
         B     STRSRCH                 GO SEARCH TABLE
BSRCH    L     R2,BPTR                 POINT TO 1ST STRING STARTING "B"
         B     STRSRCH                 GO SEARCH TABLE
CSRCH    L     R2,CPTR                 POINT TO 1ST STRING STARTING "C"
         B     STRSRCH                 GO SEARCH TABLE
DSRCH    L     R2,DPTR                 POINT TO 1ST STRING STARTING "D"
         B     STRSRCH                 GO SEARCH TABLE
ESRCH    L     R2,EPTR                 POINT TO 1ST STRING STARTING "E"
         B     STRSRCH                 GO SEARCH TABLE
FSRCH    L     R2,FPTR                 POINT TO 1ST STRING STARTING "F"
         B     STRSRCH                 GO SEARCH TABLE
GSRCH    L     R2,GPTR                 POINT TO 1ST STRING STARTING "G"
         B     STRSRCH                 GO SEARCH TABLE
HSRCH    L     R2,HPTR                 POINT TO 1ST STRING STARTING "H"
         B     STRSRCH                 GO SEARCH TABLE
ISRCH    L     R2,IPTR                 POINT TO 1ST STRING STARTING "I"
         B     STRSRCH                 GO SEARCH TABLE
JSRCH    L     R2,JPTR                 POINT TO 1ST STRING STARTING "J"
         B     STRSRCH                 GO SEARCH TABLE
KSRCH    L     R2,KPTR                 POINT TO 1ST STRING STARTING "K"
         B     STRSRCH                 GO SEARCH TABLE
LSRCH    L     R2,LPTR                 POINT TO 1ST STRING STARTING "L"
         B     STRSRCH                 GO SEARCH TABLE
MSRCH    L     R2,MPTR                 POINT TO 1ST STRING STARTING "M"
         B     STRSRCH                 GO SEARCH TABLE
NSRCH    L     R2,NPTR                 POINT TO 1ST STRING STARTING "N"
         B     STRSRCH                 GO SEARCH TABLE
OSRCH    L     R2,OPTR                 POINT TO 1ST STRING STARTING "O"
         B     STRSRCH                 GO SEARCH TABLE
PSRCH    L     R2,PPTR                 POINT TO 1ST STRING STARTING "P"
         B     STRSRCH                 GO SEARCH TABLE
QSRCH    L     R2,QPTR                 POINT TO 1ST STRING STARTING "Q"
         B     STRSRCH                 GO SEARCH TABLE
RSRCH    L     R2,RPTR                 POINT TO 1ST STRING STARTING "R"
         B     STRSRCH                 GO SEARCH TABLE
SSRCH    L     R2,SPTR                 POINT TO 1ST STRING STARTING "S"
         B     STRSRCH                 GO SEARCH TABLE
TSRCH    L     R2,TPTR                 POINT TO 1ST STRING STARTING "T"
         B     STRSRCH                 GO SEARCH TABLE
USRCH    L     R2,UPTR                 POINT TO 1ST STRING STARTING "U"
         B     STRSRCH                 GO SEARCH TABLE
VSRCH    L     R2,VPTR                 POINT TO 1ST STRING STARTING "V"
         B     STRSRCH                 GO SEARCH TABLE
WSRCH    L     R2,WPTR                 POINT TO 1ST STRING STARTING "W"
         B     STRSRCH                 GO SEARCH TABLE
XSRCH    L     R2,XPTR                 POINT TO 1ST STRING STARTING "X"
         B     STRSRCH                 GO SEARCH TABLE
YSRCH    L     R2,YPTR                 POINT TO 1ST STRING STARTING "Y"
         B     STRSRCH                 GO SEARCH TABLE
ZSRCH    L     R2,ZPTR                 POINT TO 1ST STRING STARTING "Z"
         B     STRSRCH                 GO SEARCH TABLE
HISRCH   L     R2,HIPTR                POINT TO 1ST STRING > "Z"
STRSRCH  LA    R2,0(R2)                CLEAR HI-ORDER BYTE
         C     R2,STREND               PAST END OF TABLE?
         BH    TRTSCAN                 YES, NO STRING FOUND
         SR    R1,R1                   CLEAR FOR INSERT
         ICM   R1,1,0(R2)              GET STRING LENGTH FROM ENTRY
         BZ    TRTSCAN                 LAST ENTRY, NO STRING FOUND
         CR    R1,R15                  RECORD CAN CONTAIN STRING?
         BNH   DOCMPR                  YES, GO COMPARE FOR STRING
SYSRSTEP LA    R2,74(R2)               STEP TO NEXT STRING ENTRY
         CLC   2(1,R2),0(R11)          SAME STARTING BYTE?
         BH    TRTSCAN                 NOT FOUND IF TABLE IS HIGH
         B     STRSRCH                 ELSE GO COMPARE
COMPARE  CLC   0(1,R11),2(R2)          EXECUTED COMPARE
DOCMPR   EX    R1,COMPARE              COMPARE RECORD:STRING ENTRY
         BNE   SYSRSTEP                BRANCH IF NOT EQUAL
         CLI   LGPROG,C'Y'             IS A LINE GROUP IN PROGRESS?
         BNE   NOLGPROG                NO
         CLI   1(R2),C'M'              YES, IS THIS A MTCH STRING?
         BNE   LGNOTM                  NO
         CLI   FOUNDSW,C'Y'            WAS A MTCH STRING ALREADY FOUND?
         BE    SYSRSTEP                YES, CONTINUE
         MVI   FOUNDSW,C'Y'            NO, SET MTCH FOUND FLAG
         MVC   STRINGFD,2(R2)          MOVE THE STRING FOUND
         B     SYSRSTEP                AND CONTINUE SCAN
LGNOTM   CLI   1(R2),C'T'              A TERM STRING WAS FOUND?
         BNE   LGGOTI                  NO, MUST BE AN INIT STRING
         MVI   ENDFDSW,C'Y'            YES, SET END FOUND SWITCH
         BAL   R14,ANALYSIS            PASS LINE GROUP TO ANALYSIS PGM
         B     READMEM                 GO TO NEXT INPUT RECORD
LGGOTI   BAL   R14,ANALYSIS            PASS LINE GROUP TO ANALYSIS PGM
         MVI   LGPROG,C'Y'             SHOW LINE GROUP IN PROGRESS
         L     R1,CURRLINE             POINT TO FIRST LINE AREA
         MVC   0(80,R1),MEMREC         MOVE CURRENT RECORD TO LINE GRP
         LA    R1,80(R1)               STEP TO NEXT L.G. AREA
         ST    R1,CURRLINE             SAVE UPDATED L.G. ADDRESS
         B     SYSRSTEP                CONTINUE RECORD SCAN
NOLGPROG CLI   1(R2),C'I'              THIS START OF A LINE GROUP?
         BNE   SYSRSTEP                NO
         MVI   LGPROG,C'Y'             YES, INDICATE LINE GROUP IN PROG
         B     SYSRSTEP                CONTINUE SCAN
***********************************************************************
*        END OF INPUT FILE                                            *
***********************************************************************
ENDFILE  BAL   R14,ANALYSIS            GO TO ANALYSIS ROUTINE
         CLOSE INPUT                   CLOSE CURRENT FILE
         FREEPOOL INPUT                FREE THE BUFFER
         CALL  READDIR,CLOSE           CLOSE DIRECTORY FILE
         CALL  READMEM,CLOSE           CLOSE MEMBER FILE
         B     NEWINFIL                GO TRY FOR ANOTHER FILE
***********************************************************************
* CALL ANALYSIS ROUTINE AND THEN CLEAN UP FOR NEXT GROUP.             *
***********************************************************************
ANALYSIS ST    R14,AA14                SAVE RETURN ADDRESS
         CLI   LGPROG,C'Y'             LINE GROUP IN PROGRESS?
         BNE   AARESET                 NO
         LA    R1,ANALPARM             POINT TO PARM LIST FOR PROGRAM
         L     R15,ANALPGMA            POINT TO ANALYSIS PROGRAM E.P.
         BALR  R14,R15                 EXECUTE THE ANALYSIS PROGRAM
AARESET  MVI   LGPROG,C'N'             RESET LINE GROUP IN PROGRESS
         MVI   FOUNDSW,C'N'            RESET STRING FOUND SWITCH
         MVI   ENDFDSW,C'N'            RESET END FOUND SWITCH
         MVC   STRINGFD,BLANKS         CLEAR THE STRING FOUND FIELD
         ZAP   NBRLINES,=P'0'          CLEAR GROUP LINE COUNTER
         MVC   CURRLINE,=A(LINEGRP)    SET STARTING LINE GROUP POINTER
AAXIT    L     R14,AA14                GET RETURN ADDRESS
         BR    R14                     RETURN TO CALLER
***********************************************************************
*        END OF JOB                                                   *
***********************************************************************
EOJ      CLOSE (INPUT,,SYSPRINT)       CLOSE FILES
         L     R13,4(R13)              GET CALLER'S SAVE ADDRESS
         LM    R14,R12,12(R13)         GET CALLER'S REGISTERS
         SR    R15,R15                 ZERO RETURN CODE
         BR    R14                     RETURN TO CALLER
***********************************************************************
*        STORAGE AND FILE AREAS                                       *
***********************************************************************
ANALPGMA DC    A(0)                    ANALYSIS PROGRAM E.P. ADDRESS
ANALPGMN DC    CL8' '                  ANALYSIS PROGRAM NAME
ANALPARM DC    X'80',AL3(PASSAREA)     ANALYSIS PROGRAM PARM LIST
AA14     DC    A(0)                    RETURN ADDRESS FOR ANALYSIS
TIOTDD   DC    A(0)                    ADDRESS OF CURRENT TIOT DD ENTRY
MRECND   DC    A(MEMREC+79)            ADDRESS OF END OF INPUT RECORD
MBRTBL   DC    A(0)                    FIRST MEMBER TABLE ADDRESS
MBRCURR  DC    A(0)                    CURRENT MEMBER TABLE ADDRESS
MBREND   DC    A(0)                    END OF MEMBER TABLE
STRTBL   DC    A(0)                    FIRST STRING TABLE ADDRESS
STRCURR  DC    A(0)                    CURRENT STRING TABLE ADDRESS
STREND   DC    A(0)                    END OF STRING TABLE
CURRLINE DC    A(LINEGRP)              POINTER TO CURRENT LINE
SAVEREC  DS    CL80                    ORIGINAL INPUT RECORD
STRCARD  DS    CL80                    STRING RECORD FROM INPUT
BLANKS   DC    CL133' '                CONSTANT BLANKS
HIVAL    DC    XL8'FFFFFFFFFFFFFFFF'   CONSTANT HIGH-VALUES
H80      DC    H'80'                   CONSTANT 80
LGPROG   DC    CL1'N'                  LINE GROUP IN PROGRESS (Y/N)
STRGTYPE DC    CL1'I'                  STRING TYPE
MEMTYPE  DC    C'I'                    MBR TBL TYPE E=EXCLUDE, I=NCLUDE
SEQFILE  DC    X'00'                   SIMPLE SEQUENTIAL FILE INDIC
BADTYPE  DC    CL48'FIRST RECORD IN MEMBERS FILE MUST BE INCLUDE OR '
         DC    CL42'EXCLUDE'
MEMBERHD DC    CL90'                  MEMBER SELECTION RECORDS'
STRINGHD DC    CL90'                  STRING SELECTION RECORDS'
DATAHD   DC    CL90'            DATA RECORDS FOUND CONTAINING STRINGS'
*
PRTLINE  DS    0CL133                  PRINT LINE
PCC      DC    C' '                      CARRIAGE CONTROL
PRT      DC    CL132' '                  PRINT DATA LINE
*
STARS    DC    90C'*'                  LINE OF STARS
LDADDRS  DS    0F                      ADDRESS TABLE
EOF      EQU   X'FF'                   MEMBER EOF INDICATOR
EOFHI    EQU   C'Z'                    DIRECTORY EOF INDICATOR (HIGH)
EOFLO    EQU   C' '                    DIRECTORY EOF INDICATOR (LOW)
LOWPTR   DC    A(HIVAL)                FOR STRINGS < "A"
APTR     DC    C'A',AL3(HIVAL)         FOR STRINGS STARTING "A"
BPTR     DC    C'B',AL3(HIVAL)         FOR STRINGS STARTING "B"
CPTR     DC    C'C',AL3(HIVAL)         FOR STRINGS STARTING "C"
DPTR     DC    C'D',AL3(HIVAL)         FOR STRINGS STARTING "D"
EPTR     DC    C'E',AL3(HIVAL)         FOR STRINGS STARTING "E"
FPTR     DC    C'F',AL3(HIVAL)         FOR STRINGS STARTING "F"
GPTR     DC    C'G',AL3(HIVAL)         FOR STRINGS STARTING "G"
HPTR     DC    C'H',AL3(HIVAL)         FOR STRINGS STARTING "H"
IPTR     DC    C'I',AL3(HIVAL)         FOR STRINGS STARTING "I"
JPTR     DC    C'J',AL3(HIVAL)         FOR STRINGS STARTING "J"
KPTR     DC    C'K',AL3(HIVAL)         FOR STRINGS STARTING "K"
LPTR     DC    C'L',AL3(HIVAL)         FOR STRINGS STARTING "L"
MPTR     DC    C'M',AL3(HIVAL)         FOR STRINGS STARTING "M"
NPTR     DC    C'N',AL3(HIVAL)         FOR STRINGS STARTING "N"
OPTR     DC    C'O',AL3(HIVAL)         FOR STRINGS STARTING "O"
PPTR     DC    C'P',AL3(HIVAL)         FOR STRINGS STARTING "P"
QPTR     DC    C'Q',AL3(HIVAL)         FOR STRINGS STARTING "Q"
RPTR     DC    C'R',AL3(HIVAL)         FOR STRINGS STARTING "R"
SPTR     DC    C'S',AL3(HIVAL)         FOR STRINGS STARTING "S"
TPTR     DC    C'T',AL3(HIVAL)         FOR STRINGS STARTING "T"
UPTR     DC    C'U',AL3(HIVAL)         FOR STRINGS STARTING "U"
VPTR     DC    C'V',AL3(HIVAL)         FOR STRINGS STARTING "V"
WPTR     DC    C'W',AL3(HIVAL)         FOR STRINGS STARTING "W"
XPTR     DC    C'X',AL3(HIVAL)         FOR STRINGS STARTING "X"
YPTR     DC    C'Y',AL3(HIVAL)         FOR STRINGS STARTING "Y"
ZPTR     DC    C'Z',AL3(HIVAL)         FOR STRINGS STARTING "Z"
HIPTR    DC    C'0',AL3(HIVAL)         FOR STRINGS STARTING > "Z"
LDADEND  DC    A(*)                    END OF TABLE POINTER "A"
*
OPEN     DC    CL9'OINPUT'             OPEN PARAMETER LIST
CLOSE    DC    CL9'CINPUT'             CLOSE PARAMETER LIST
READ     DC    C'R'                    READ PARAMETER
*
DIRECTRY DS    0CL11                   DIRECTORY DATA
MEMNAME  DS    CL8                     MEMBER NAME
MEMTTR   DS    XL3                     TTR OF FIRST BLOCK
*
FIND     DS    0CL10                   FIND MEMBER PARAMETER LIST
         DC    C'FN'                   FIND BY NAME
FINDNAM  DS    CL8                     NAME TO BE FOUND
*
MEMREC   DS    CL80                    MEMBER RECORD
*
JFCAD    DS    0F
         DC    X'87'                   END OF LIST, JFCB ADDR
         DC    AL3(JFCB)               ADDRESS OF JFCB AREA
JFCB     DS    CL176                   JFCB FOR INPUT
JFCLRECL EQU   JFCB+104,2              LRECL
JFCRECFM EQU   JFCB+100,1              RECFM
JFCDSORG EQU   JFCB+98,1               DSORG
JFCELNM  EQU   JFCB+44,8               MEMBER NAME
*
INPUT    DCB   DSORG=PS,MACRF=GM,DDNAME=INPUT,EXLST=JFCAD,             X
               EODAD=ENDFILE
STRINGS  DCB   DSORG=PS,MACRF=GM,DDNAME=STRGINIT,                      X
               RECFM=FB,LRECL=80,EODAD=ENDINIT
MEMBERS  DCB   DSORG=PS,MACRF=GM,DDNAME=MEMBERS,                       X
               RECFM=FB,LRECL=80,EODAD=ENDMBTBL
SYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X
               RECFM=FBA,LRECL=133
*
*        TRT SCANNING TABLE TO FIND POSSIBLE STRING
TRTSCH   DC    256X'00'
*              TRANSLATE LOWER TO UPPER CASE
UPRCASE  DC    XL16'000102030405060708090A0B0C0D0E0F'
         DC    XL16'101112131415161718191A1B1C1D1E1F'
         DC    XL16'202122232425262728292A2B2C2D2E2F'
         DC    XL16'303132333435363738393A3B3C3D3E3F'
         DC    XL16'404142434445464748494A4B4C4D4E4F'
         DC    XL16'505152535455565758595A5B5C5D5E5F'
         DC    XL16'606162636465666768696A6B6C6D6E6F'
         DC    XL16'707172737475767778797A7B7C7D7E7F'
         DC    XL16'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'
         DC    XL16'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'
         DC    XL16'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'
         DC    XL16'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    XL16'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'
         DC    XL16'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
         DC    XL16'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'
         LTORG
PASSAREA DS    0D       AREA PASSED TO ANALYSIS PROGRAM
DSNAME   DC    CL44' '      DSNAME OF FILE BEING PROCESSED
MEMBER   DC    CL8' '       MEMBER NAME OF FILE BEING PROCESSED
STRINGFD DC    CL72' '      MATCH STRING FOUND (IF FOUNDSW=Y)
FOUNDSW  DC    CL1' '       STRING FOUND SWITCH (Y OR N)
ENDFDSW  DC    CL1' '       END FOUND SWITCH (Y OR N)
NBRLINES DC    PL2'000'     NUMBER OF LINES IN THE GROUP
LINEGRP  DS    100CL80      GROUP OF LINES COMPRISING THE COBOL STMT.
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
